[
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "EKTAAY",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/Renee_Headshot.jpg",
    "name": "Renee Spear",
    "code": "N8TQHP",
    "biography": "Renee Spear is a senior at Embry-Riddle Aeronautical University - Prescott, AZ majoring in Aerospace Engineering, Astronautical track, and minoring in Computer Science. Renee has been involved in the Julia Language 1.0 Ephemeris and Physical Constants Reader for Solar System bodies with her peer, Julia Mihaylov, and mentors, Dr. Kaela Martin of Embry-Riddle Aeronautical University and Dr. Damon Landau of the Jet Propulsion Laboratory, for over two years and has published two papers on the subject. Her career goals include pursuing an advanced degree in astrodynamics and working for an aerospace company where she can make an impact on spacecraft and mission design through the optimization of existing procedures and exploration of new avenues in technology and design. Outside of academia, Renee loves to enjoy the outdoors through hiking, photography, kayaking, and backpacking."
   }
  ],
  "description": "With computation time being a critical factor in trajectory optimization, this code has aimed for and accomplished a higher computational efficiency than the original code designed in MATLAB®. The ephemeris reader acquires necessary data for mission design from public JPL websites and calculates positions, velocities, accelerations, and other characteristics of major and small bodies at any user-defined times using the extracted data. Additionally, the second generation of this ephemeris reader introduces shape models of known asteroids as well as spherical harmonics capabilities to support gravitational potential models. This version of the ephemeris reader is also compatible with Julia 1.0 which was released in August of 2018. This second-generation version continues to support the obtainment of critical information needed for mission and trajectory design faster and with added efficiency.\r\n\r\nThis lightning talk will discuss a more detailed overview as well as why Julia was chosen for this project.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T17:35:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-25T17:45:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "The Julia Language 1.0 Ephemeris and Physical Constants Reader for Solar System Bodies",
  "abstract": "The Julia Language 1.0 Ephemeris and Physical Constants Reader for Solar System Bodies is an ephemeris reader, written in the programming language of Julia, is a new tool intended for use in astrodynamic applications."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "B38TDU",
  "track": null,
  "state": "confirmed",
  "duration": 60,
  "speakers": [
   {
    "avatar": null,
    "name": "Curtis Vogt",
    "code": "AQLMAC",
    "biography": null
   }
  ],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T15:45:00-04:00",
   "room": {
    "en": "BoF: Room 353"
   },
   "end": "2019-07-24T16:45:00-04:00"
  },
  "submission_type": {
   "en": "Birds of Feather"
  },
  "resources": [],
  "do_not_record": true,
  "title": "Julia In Production",
  "abstract": "A casual chat about the virtues and concerns relating to running julia in a production enviroment."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "QZBKAU",
  "track": null,
  "state": "confirmed",
  "duration": 120,
  "speakers": [
   {
    "avatar": null,
    "name": "Juan Pablo Vielma",
    "code": "PFCA7P",
    "biography": "Juan Pablo Vielma is an associate professor at MIT’s Sloan School of Management and is also associated to MIT’s Operations Research Center. Juan Pablo’s research interests include the development of theory and technology for mathematical optimization and their application to problems in marketing, statistics and sustainable management of energy and natural resources. Juan Pablo is the Ph.D. advisor of two of the creators of JuMP and continues to be closely involved in JuMP’s development. Some projects he is currently associated with are the Pajarito, Hypatia and Aspasia Solver, JuMP’s extension for piecewise linear optimization and the Cassette and Capstan tools."
   },
   {
    "avatar": "https://pretalx.com/media/avatars/head_o3pWJVJ.jpg",
    "name": "Lea Kapelevich",
    "code": "LXPRY3",
    "biography": "PhD student at the Operations Research Center at MIT."
   },
   {
    "avatar": null,
    "name": "Chris Coey",
    "code": "M77DBG",
    "biography": "Doctoral student at MIT Operations Research Center, advised by Juan Pablo Vielma"
   },
   {
    "avatar": null,
    "name": "Benoît Legat",
    "code": "AYKX8W",
    "biography": null
   },
   {
    "avatar": null,
    "name": "Tillmann Weisser",
    "code": "C8BZZ7",
    "biography": null
   }
  ],
  "description": "Polynomial and moment optimization problems are infinite dimensional optimization problems that can model a wide range of problems such as shape-constrained polynomial regression, optimal control of dynamical systems, region of attraction, polynomial matrix decomposition, smooth maximum-likelihood density estimation, AC power systems, experimental design, and computation of Nash equilibria. In this minisymposium we show how the [Julia](https://julialang.org) and [JuMP](https://github.com/JuliaOpt/JuMP.jl) ecosystems are particularly well suited for constructing and solving these problems. In particular, we show how the JuMP extensions [SumOfSquares](https://github.com/JuliaOpt/SumOfSquares.jl)/[PolyJuMP](https://github.com/JuliaOpt/PolyJuMP.jl) allow for an effortless construction of these problems and how they provide a flexible and customizable building block for additional packages such as JuliaMoments. We also show how various features of the Julia programming language are used in the state-of-the-art solvers Hypatia.jl and Aspasia.jl. Finally, we showcase specific uses of these tools for applications in engineering and statistics.",
  "image": "https://pretalx.com/media/juliacon2019/images/QZBKAU/jump-logo-with-text-600ppi.png",
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T15:45:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-24T17:45:00-04:00"
  },
  "submission_type": {
   "en": "Minisymposia / Extended Presentation"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Polynomial and Moment Optimization in Julia and JuMP",
  "abstract": "Polynomial and moment optimization problems are infinite dimensional optimization problems that can model a wide range of problems in engineering and statistics. In this minisymposium we show how the Julia and JuMP ecosystems are particularly well suited for the effortless construction of these problems and the development of state-of-the-art solvers for them."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "GMRBWB",
  "track": null,
  "state": "confirmed",
  "duration": 60,
  "speakers": [
   {
    "avatar": null,
    "name": "Stefan Karpinski",
    "code": "9NNRE7",
    "biography": "Stefan is one of the co-creators of Julia and a co-founder of Julia Computing. Before Julia, he was a software engineer and data scientist at [Akamai](https://www.akamai.com), [Citrix Online](https://www.gotomeeting.com), and [Etsy](https://etsy.com). In addition to running Julia Computing, he holds a part-time appointment as a Research Engineer at New York University as part of the Moore-Sloan Data Science Environment."
   }
  ],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T15:45:00-04:00",
   "room": {
    "en": "BoF: Room 353"
   },
   "end": "2019-07-25T16:45:00-04:00"
  },
  "submission_type": {
   "en": "Birds of Feather"
  },
  "resources": [],
  "do_not_record": true,
  "title": "Package Management BoF",
  "abstract": "Everything Pkg: discussion of package management, version resolution, binary artifacts, registries, manifests, configuration, etc."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "CNQ9JB",
  "track": null,
  "state": "confirmed",
  "duration": 150,
  "speakers": [],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T19:00:00-04:00",
   "room": {
    "en": "Other"
   },
   "end": "2019-07-23T21:30:00-04:00"
  },
  "submission_type": {
   "en": "Break"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Conference Dinner and Inner Harbor Cruise",
  "abstract": "A conference dinner and cruise are planned on Tuesday evening for all ticketed attendees. Boarding is at 7:00 PM  in front of the Baltimore Visitor Center located on the promenade facing Light Street. *All participants are expected to bring the conference badges for identification*. Boarding will be complete by 7:25 PM and the Cruise begins at sharp 7:30 PM. Dinner will be served at 8:00 PM so, feel free to get a light snack if it’s too late. There will be a DJ onboard in case anyone wants to put on their dancing shoes.  Further details will be announced on-site."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "APPUNN",
  "track": null,
  "state": "confirmed",
  "duration": 60,
  "speakers": [
   {
    "avatar": null,
    "name": "Valentin Churavy",
    "code": "3C7UBC",
    "biography": "PhD student at the MIT JuliaLab, HPC enthusiast."
   },
   {
    "avatar": null,
    "name": "Jarrett Revels",
    "code": "8H8WP7",
    "biography": null
   }
  ],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T16:35:00-04:00",
   "room": {
    "en": "BoF: Room 353"
   },
   "end": "2019-07-23T17:35:00-04:00"
  },
  "submission_type": {
   "en": "Birds of Feather"
  },
  "resources": [],
  "do_not_record": true,
  "title": "Cassette and company -- Dynamic compiler passes",
  "abstract": "Chat about Cassette,  Vinyl, IRTools, and Aborist. Things that rewrite the code at compile-time, based on context."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "BACLJQ",
  "track": null,
  "state": "confirmed",
  "duration": 50,
  "speakers": [
   {
    "avatar": null,
    "name": "Valentin Churavy",
    "code": "3C7UBC",
    "biography": "PhD student at the MIT JuliaLab, HPC enthusiast."
   },
   {
    "avatar": null,
    "name": "Tim Besard",
    "code": "9YQMAK",
    "biography": null
   }
  ],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T16:45:00-04:00",
   "room": {
    "en": "BoF: Room 353"
   },
   "end": "2019-07-24T17:35:00-04:00"
  },
  "submission_type": {
   "en": "Birds of Feather"
  },
  "resources": [],
  "do_not_record": true,
  "title": "JuliaGPU",
  "abstract": "A discussion of the Julia GPU ecosystem"
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "MC8TPZ",
  "track": null,
  "state": "confirmed",
  "duration": 50,
  "speakers": [
   {
    "avatar": null,
    "name": "Mosè Giordano",
    "code": "ST7KZT",
    "biography": "I am a Research Software Developer at UCL"
   }
  ],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T16:45:00-04:00",
   "room": {
    "en": "BoF: Room 353"
   },
   "end": "2019-07-25T17:35:00-04:00"
  },
  "submission_type": {
   "en": "Birds of Feather"
  },
  "resources": [],
  "do_not_record": true,
  "title": "Julia in Astronomy",
  "abstract": "Casual chats about the uses of Julia in Astronomy, JuliaAstro and related packages and studies."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "XH89CV",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "JinGuo Liu",
    "code": "QBUZQE",
    "biography": "https://github.com/GiggleLiu/CV/blob/master/cv.pdf"
   }
  ],
  "description": "A tensor network is a contraction of tensors, it has wide applications in fields of physics, big data and machine learning. It can be used to represent a quantum wave function ansatz, compress data and model probabilities. Supporting automatic differentiation brings hope for many difficult problems like training project entangled pair states. We provide a unified, dispatchable interface for `einsum` as the middleware to port tensor contraction libraries and tensor network applications and a through support to back-propagation through linear algebra functions. Based on these supporting libraries, we show some tensor network algorithms as examples.\r\n\r\nReferences:\r\n* Differentiable Programming Tensor Networks, Hai-Jun Liao, Jin-Guo Liu, Lei Wang, and Tao Xiang [under preparation]\r\n* Unsupervised Generative Modeling Using Matrix Product States, Zhao-Yu Han, Jun Wang, Heng Fan, Lei Wang, and Pan Zhang Phys. Rev. X 8, 031012",
  "image": "https://pretalx.com/media/juliacon2019/images/XH89CV/ome-logo_1QI17O3.png",
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T11:40:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-25T11:50:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Differential Programming Tensor Networks",
  "abstract": "A package about einsum, as well as differentiable tensor network algorithms built on top of it. Why we need automatic differentiating tensor networks and how to achieve this goal."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "JGY7KC",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Avik Pal",
    "code": "KK8JUK",
    "biography": "Sophomore Undergraduate Student majoring in Computer Science and Technology at Indian Institute of Technology Kanpur."
   }
  ],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T16:15:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-24T16:25:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Differentiable Rendering and its Applications in Deep Learning",
  "abstract": "RayTracer.jl is a package designed for differentiable rendering. In this talk, I shall discuss the inverse graphics problem and how differentiable rendering can help solve it. Apart from this we will see how differentiable rendering can be used in differentiable programming pipelines along with neural networks to solve classical deep learning problems."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "TFFARR",
  "track": null,
  "state": "confirmed",
  "duration": 50,
  "speakers": [
   {
    "avatar": null,
    "name": "Viral B. Shah",
    "code": "3HK3M7",
    "biography": null
   }
  ],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T15:45:00-04:00",
   "room": {
    "en": "BoF: Room 353"
   },
   "end": "2019-07-23T16:35:00-04:00"
  },
  "submission_type": {
   "en": "Birds of Feather"
  },
  "resources": [],
  "do_not_record": true,
  "title": "Julia and NumFocus, a discussion of how money works",
  "abstract": "Discussion on how Julia as a community handles money, sponsorship and grants."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "83YFMV",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/jeff_bezanson.jpeg",
    "name": "Jeff Bezanson",
    "code": "JWDSCE",
    "biography": "Jeff is one of the creators of Julia, co-founding the project at MIT in 2009 and eventually receiving a Ph.D. related to the language in 2015. He continues to work on the compiler and system internals, while also working to expand Julia’s commercial reach as a co-founder of Julia Computing, Inc."
   }
  ],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T11:40:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-23T11:50:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Thread Based Parallelism part 2",
  "abstract": "Hear about what is new in julia 1.2 and 1.3 with thread-based parallelism.\r\n(note: due to a race condition, Thread Based Parallelism part 2 occurs before Thread Based Parallelism part 1)"
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "3YQSSP",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Jameson Nash",
    "code": "GKZDHU",
    "biography": null
   }
  ],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T11:50:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-23T12:00:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Thread Based Parallelism part 1",
  "abstract": "Hear about what is new in julia 1.2 and 1.3 with thread-based parallelism.\r\n(note: due to a race condition, Thread Based Parallelism part 1 occurs after Thread Based Parallelism part 2)"
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "D7NVW8",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/favicon.jpeg",
    "name": "Roger Luo",
    "code": "VRCN8Y",
    "biography": "First year grad student from University of Waterloo.  Core member of JuliaCN, the Julia localization org in China. Core member of QuantumBFS, an open source organization for developing software for quantum physics."
   }
  ],
  "description": "## Introduction\r\n\r\n[JuliaCN](https://github.com/JuliaCN) was founded when Julia was still newly born. Its early member includes several developers in the community, e.g Jiahao Chen, Yichao Yu.  We provided the first translation on Julia's documentation in v0.3, known as [julia_zh_cn](https://github.com/JuliaCN/julia_zh_cn). Later, we provided [the Chinese discourse](https://discourse.juliacn.com/) to let non-English speakers communicate freely and get support when they are in trouble. \r\n\r\n## Activities\r\n\r\n- Annual Julia User Meetup in China: This is more like a small workshop held each year.\r\n- Holding and providing resource for Julia User Meetups\r\n- Community driven translation project: we built a transifex based translation project [JuliaZH.jl](https://github.com/JuliaCN/JuliaZH.jl)\r\n\r\n### Project Emerged in JuliaCN Community\r\n\r\n- [Jetbrain IDE for Julia](https://plugins.jetbrains.com/plugin/10413-julia)\r\n- [Py2JI.jl](https://github.com/JuliaCN/Py2Jl.jl)",
  "image": "https://pretalx.com/media/juliacon2019/images/D7NVW8/logo.png",
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T11:50:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-25T12:00:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "JuliaCN: A community driven localization group for Julia in China",
  "abstract": "JuliaCN was founded by early Chinese Julia developers for Julia localization in Chinese. We started it by providing Chinese translation on Julia documentation known as [JuliaZH.jl](https://github.com/JuliaCN/JuliaZH.jl)/[julia_zh_cn](https://github.com/JuliaCN/julia_zh_cn)."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "3JFX8K",
  "track": null,
  "state": "confirmed",
  "duration": 480,
  "speakers": [],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-26T08:30:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-26T16:30:00-04:00"
  },
  "submission_type": {
   "en": "Workshop (full day)"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Hackathon",
  "abstract": "The hackathon. Come work on projects, have discussions about converging ecosystems, and generally hang out.\r\nNote: both Elm A and Elm B will be used."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "3RGNK9",
  "track": null,
  "state": "confirmed",
  "duration": 60,
  "speakers": [],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-22T07:30:00-04:00",
   "room": {
    "en": "Other"
   },
   "end": "2019-07-22T08:30:00-04:00"
  },
  "submission_type": {
   "en": "Break"
  },
  "resources": [],
  "do_not_record": true,
  "title": "Breakfast (Workshops)",
  "abstract": "Breakfast will be provided in the PH Galley"
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "WVVALL",
  "track": null,
  "state": "confirmed",
  "duration": 75,
  "speakers": [],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-22T12:00:00-04:00",
   "room": {
    "en": "Other"
   },
   "end": "2019-07-22T13:15:00-04:00"
  },
  "submission_type": {
   "en": "Break"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Lunch",
  "abstract": "Lunch will be held in the SMC 2nd Floor Lobby"
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "ESLAXZ",
  "track": null,
  "state": "confirmed",
  "duration": 75,
  "speakers": [],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T12:05:00-04:00",
   "room": {
    "en": "Other"
   },
   "end": "2019-07-23T13:20:00-04:00"
  },
  "submission_type": {
   "en": "Break"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Lunch",
  "abstract": "Lunch will be held in the SMC 2nd Floor Lobby"
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "YCGCVE",
  "track": null,
  "state": "confirmed",
  "duration": 75,
  "speakers": [],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T12:00:00-04:00",
   "room": {
    "en": "Other"
   },
   "end": "2019-07-24T13:15:00-04:00"
  },
  "submission_type": {
   "en": "Break"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Lunch",
  "abstract": "Lunch will be held in the SMC 2nd Floor Lobby"
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "XPVUEX",
  "track": null,
  "state": "confirmed",
  "duration": 75,
  "speakers": [],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T12:00:00-04:00",
   "room": {
    "en": "Other"
   },
   "end": "2019-07-25T13:15:00-04:00"
  },
  "submission_type": {
   "en": "Break"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Lunch",
  "abstract": "Lunch will be held in the SMC 2nd Floor Lobby"
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "KLDTNJ",
  "track": null,
  "state": "confirmed",
  "duration": 75,
  "speakers": [],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-26T12:00:00-04:00",
   "room": {
    "en": "Other"
   },
   "end": "2019-07-26T13:15:00-04:00"
  },
  "submission_type": {
   "en": "Break"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Lunch",
  "abstract": "Lunch will be held in the SMC 2nd Floor Lobby"
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "YX9NNS",
  "track": null,
  "state": "confirmed",
  "duration": 60,
  "speakers": [],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T07:30:00-04:00",
   "room": {
    "en": "Other"
   },
   "end": "2019-07-25T08:30:00-04:00"
  },
  "submission_type": {
   "en": "Break"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Breakfast",
  "abstract": "Breakfast will be held in the SMC 2nd Floor Lobby"
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "CQM3RC",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": null,
    "name": "Nathan Daly",
    "code": "JP9VJF",
    "biography": "Nathan Daly is a Software Engineer at [RelationalAI](http://relational.ai). He was first introduced to the idea of contributing to JuliaLang as one small way to help fight climate change by making scientific computing a little bit easier: http://worrydream.com/ClimateChange"
   }
  ],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T10:15:00-04:00",
   "room": {
    "en": "NS Room 130"
   },
   "end": "2019-07-23T10:20:00-04:00"
  },
  "submission_type": {
   "en": "Sponsor's Address"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Sponsor Address: Relational AI",
  "abstract": "A talk from one of our gracious sponsors."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "VXFNVA",
  "track": null,
  "state": "confirmed",
  "duration": 60,
  "speakers": [],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T07:30:00-04:00",
   "room": {
    "en": "Other"
   },
   "end": "2019-07-24T08:30:00-04:00"
  },
  "submission_type": {
   "en": "Break"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Breakfast",
  "abstract": "Breakfast will be held in the SMC 2nd Floor Lobby"
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "JRCQHU",
  "track": null,
  "state": "confirmed",
  "duration": 60,
  "speakers": [],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T07:30:00-04:00",
   "room": {
    "en": "Other"
   },
   "end": "2019-07-23T08:30:00-04:00"
  },
  "submission_type": {
   "en": "Break"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Breakfast",
  "abstract": "Breakfast will be held in the SMC 2nd Floor Lobby"
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "YZPSDK",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Mary McGrath",
    "code": "UAS9XY",
    "biography": "Mary is a data scientist with Brown's Center for Computation and Visualization and the Brown Center for Biomedical Informatics.  Her background is in health analytics and biomedical engineering."
   }
  ],
  "description": "Using Julia and Vega to jumpstart development of interactive visualizations helps bridge the gap between analysis done on your laptop and publishing compelling results to the web.  This talk will show how you can use the language, tools, and development environment you love with Julia and have web-ready interactive graphics ready to deploy.  We'll highlight the use of DataVoyager.jl for data exploration, how to use DataVoyager plots to quick-start your visualizations in VegaLite.jl, adding interactivity to your visualizations, and finally how this translates to the web.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T16:55:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-23T17:05:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Prototyping Visualizations for the Web with Vega and Julia",
  "abstract": "The internet is a powerful medium for story telling in data science, but creating compelling, interactive graphics can be difficult.  This talk will show how Vega (VegaLite.jl) and Julia can be used to prototype interactive visualizations, and then how those visualizations can be deployed to the web."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "7SX9LN",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/BramLowRes.png",
    "name": "Bram De Jaegher",
    "code": "HUECM7",
    "biography": "A PhD student at Ghent University and VITO currently working on developing models for electrochemical processes. As a bio-science engineer that loves mathematical modelling, I transform real-life systems into virtual systems and have experience in computational fluid dynamics, machine learning and bioprocess technology."
   }
  ],
  "description": "Electrodialysis is a separation technology that uses electric fields and ion-exchange membranes to separate charged components from solutions. Electrodialysis is a highly efficient technology with prominent applications in the production of drinking water from seawater and the recovery and upgrading of various bio-based resources.\r\n\r\nThe majority of physical and electrochemical phenomena are well understood and can be described by mechanistic models. The complex and intricate interplay of various phenomena that occur at the surface of the ion-exchange membranes add an incredible amount of complexity and a mechanistic description is often too difficult. The Julia ecosystem provides a unique opportunity to couple differential equation solvers with machine learning techniques such as neural networks as a hybrid approach to model these kind of systems. Automatic differentation facilitates the optimisation procedure and is interesting from an engineering point of view.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T16:45:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-25T16:55:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": true,
  "title": "An advanced electrodialysis process model in the Julia ecosystem",
  "abstract": "Electrodialysis, a prominent technology in the production of drinking water from seawater is modelled using the Julia ecosystem. A framework of partial differential equations and neural networks is solved to model the fouling of this process and to optimise its design and operation."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "VANP8R",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Aaron Christianson",
    "code": "PHBURX",
    "biography": "Aaron was born in rural Wisconsin, but has also lived in Copenhagen, Brussels, Jerusalem and currently resides in Frankfurt, doing Hebrew-related string mangling for the Goethe University library, despite his degrees in Bible and Theology. He likes small, beautiful programs and programming languages and dislikes unnecessary complexity. He also likes fancy keyboards."
   }
  ],
  "description": "Like Perl, Ruby and Bash, Julia offers backtick syntax as an abstraction for dealing with processes. However, while other languages use this syntax to invoke a shell and grab the output, backticks in Julia invoke a mini-parser for it's own safe version of a shell language and they evaluate to a command literal just waiting to be run, never invoking a shell.\r\n\r\nThis talk will go over the details of how command literals are parsed in Julia, what the resulting object looks like, and why the Julia approach to commands is a significant improvement over what shell wrappers in other languages provide (including and especially the POSIX shell itself). Of course, it will also include many examples of how to use command literals effectively.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T11:30:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-24T11:40:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Backticks and the Glorious Command  Literal",
  "abstract": "Julia command literals are one of the most compelling abstractions for dealing with processes in any programming language. This talk will show what these command literals offer that similar constructs in other languages do not and how they can be used to write safer, more robust shell scripts."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "JANJFM",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Seth Bromberger",
    "code": "JNUKRT",
    "biography": "Seth Bromberger has been involved in network and systems security for over twenty years. His work history spans multiple industries and sectors including government, finance, and energy.\r\n\r\nAt Lawrence Livermore National Laboratory, Seth is exploring practical methods to improve the security of next-generation critical infrastructure. Previously, he was Principal at NCI Security, a consulting firm dedicated to the protection of domestic and international critical infrastructure, and was the Executive Vice President of Classified and Government Programs at Energy Sector Security Consortium, a registered 501(c)(3) non-profit organization he co-founded in 2008.\r\n\r\nSeth's research interests include critical infrastructure protection, industrial control system and network security, and the security of emerging energy technologies such as Advanced Metering Infrastructure and Smart Grid systems. He is an active participant in several industry working groups and has been recognized in multiple sectors as a security thought leader and leading security practitioner.\r\n\r\nSeth's work on large scale data analysis and multi-source correlation techniques resulted in his being the listed inventor on patent application 13/339,509, “System And Method For Monitoring a Utility Meter Network”, which describes the TopSight system he developed to detect anomalous behavior in a multi-million node Smart Meter network while at Pacific Gas and Electric Company. He is also co-developer of the system described in patent application PCT/ US2013/026504, “Method and System for Packet Acquisition, Analysis and Intrusion Detection in Field Area Networks” which is being used by utilities to analyze the complex interactions among devices participating in large-scale mesh networks. Most recently, Seth conceived and developed the NetCanary system which is designed to detect reconnaissance attempts against critical infrastructure and other systems.\r\n\r\nSeth received his B.A. in International Relations from the College of William and Mary and an M.S. in Computer Engineering from the University of Pennsylvania.\r\n\r\nA list of presentations and publications may be found on [Seth's personal site](https://www.bromberger.com)."
   }
  ],
  "description": "This talk stems from the author's (eventually successful) attempt to deploy Julia along with associated packages on a secure network. Last year there was a fairly long discourse thread on this subject; this talk will serve as a followup to the initial attempts and will discuss lessons learned and advice for those seeking to use Julia in restricted environments.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T09:50:00-04:00",
   "room": {
    "en": "NS Room 130"
   },
   "end": "2019-07-24T10:00:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Using Julia in Secure Environments",
  "abstract": "As a product of the academic community, Julia has been developed with certain assumptions relating to source code availability and access. In secure environments, however, access to public (and even private) package repositories can be deliberately limited. It is still possible to use Julia in these environments: this talk will provide an overview of the challenges in deploying Julia in secure/controlled environments and discuss lessons learned from a real-world deployment on a secure system."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "DLQMQU",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/IMG_3996.jpg",
    "name": "benjamin chu",
    "code": "VPM8QT",
    "biography": "Hi there.\r\n\r\nI am a 3rd year graduate student from the department of Biomathematics at University of California, Los Angeles. I love [speedcubing](https://www.worldcubeassociation.org/persons/2012CHUB01), [coding](https://github.com/biona001), swimming, [anime](https://myanimelist.net/animelist/biona001), [piano](https://www.youtube.com/watch?v=VZS6yb8rXX8), and brewing milk tea. I also used to love jigsaw puzzles, yoyo, go, calligraphy…. but my interest comes and goes. Last year I participate in google summer of code with Julia!"
   }
  ],
  "description": "**Background:** Marginal regression is widely employed by the genomics community to identify variants associated with complex traits. Ideally one would consider all covariates in tandem, but existing multivariate methods are sub-ideal to handle common issues of a modern genome wide association study (GWAS). Here we fill the gap with a new multivariate algorithm - iterative hard thresholding (IHT).\r\n\r\n**Method:** We introduce a novel coefficient estimation scheme based on maximum likelihoods, extending the IHT algorithm to perform multivariate model estimation for any exponential family. We further discuss and implement doubly-sparse and prior knowledge-aided variants of IHT to tackle specific problems in genetics, such as linkage disequilibrium.\r\n\r\n**Results:** We show how to apply IHT for any generalized linear model, and explicitly derive the updating algorithm and optimal step length for logistic and Poisson models. We provide an efficient implementation of IHT in Julia to analyze GWAS data as a module under [OpenMendel](https://github.com/OpenMendel). We tested our algorithm on real and simulated data to demonstrate model quality, algorithm robustness, and scalability. Then we investigate when and how (group)-(within-group) sparsity and knowledge-aided projections may help in discovering rare genetic variants with small effect size. Our implementation enjoys built-in parallelism, operates directly on raw genotype files, and is completely [open sourced](https://github.com/biona001/MendelIHT.jl).\r\n\r\n**Significance:** For geneticists, our method offers enhanced multivariate model selection for big data GWAS. For theorists, we demonstrate how to use IHT to find GLM coefficients, and we derive 2 variants of the thresholding operators and show when they are expected to perform better.",
  "image": "https://pretalx.com/media/juliacon2019/images/DLQMQU/gregor-mendel-3.jpg",
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T17:15:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-25T17:25:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "MendelIHT.jl: How to fit Generalized Linear Models for High Dimensional Genetics (GWAS) Data",
  "abstract": "GWAS data are extremely high dimensional, large (>100GB), dense, and typically contains rare and correlated predictors. In this talk we discuss its unique data structures, how to efficiently represent it with Julia, how `MendelIHT.jl` in conjunction with `Distributions.jl` and `GLM.jl` fits generalized linear models for GWAS data, and the role of parallel computing."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "9GAZTS",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Dr. Paulito Palmes, PhD",
    "code": "3EKCYY",
    "biography": "I am a research scientist at the IBM Dublin Research Lab working in the areas of analytics, datamining, optimization, development of intelligent agents using machine learning and evolutionary computation, neuroinformatics, and biomedical engineering."
   }
  ],
  "description": "Over the past years, the industrial sector has seen many innovations brought about by automation. Inherent in this automation is the installation of sensor networks for status monitoring and data collection. One of the major challenges in these data-rich environments is how to extract and exploit information from these large volume of data to detect anomalies, discover patterns to reduce downtimes and manufacturing errors, reduce energy usage, etc.\r\n\r\nTo address these issues, we developed TSML package. It leverages AI and ML libraries from ScikitLearn, Caret, and Julia as building blocks in processing huge amount of industrial time series data. It has the following characteristics:\r\n- TS data type clustering/classification for automatic data discovery\r\n- TS aggregation based on date/time interval\r\n- TS imputation based on symmetric Nearest Neighbors\r\n- TS statistical metrics for data quality assessment\r\n- TS ML wrapper with more than 100+ libraries from caret, scikitlearn, and julia\r\n- TS date/value matrix conversion of 1-D TS using sliding windows for ML input\r\n- Common API wrappers for ML libs from JuliaML, PyCall, and RCall\r\n- Pipeline API allows high-level description of the processing workflow\r\n- Specific cleaning/normalization workflow based on data type\r\n- Automatic selection of optimised ML model\r\n- Automatic segmentation of time-series data into matrix form for ML training and prediction\r\n- Easily extensible architecture by using just two main interfaces: fit and transform\r\n- Meta-ensembles for robust prediction\r\n- Support for distributed computation, for scalability, and speed\r\n\r\nTSML uses a pipeline which iteratively calls the fit and transform families of functions relying on multiple dispatch to select the correct algorithm. Machine learning functions in TSML are wrappers to the corresponding Scikit-learn, Caret, and native Julia ML libraries. There are more than hundred classifiers and regression functions available using a common API.\r\n\r\nFull TSML documentation: https://ibm.github.io/TSML.jl/stable/",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T15:20:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-23T15:30:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "TSML (Time Series Machine Learning)",
  "abstract": "TSML is a package for time series data processing, classification, and prediction. It provides common API for ML libraries from Python's ScikitLearn, R's caret, and native Julia MLs for seamless integration of heterogenous libraries to create complex ensembles for robust time-series preprocessing, prediction, clustering, and classification."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "9NK3HY",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Viral B. Shah",
    "code": "3HK3M7",
    "biography": null
   }
  ],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T10:05:00-04:00",
   "room": {
    "en": "NS Room 130"
   },
   "end": "2019-07-23T10:15:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Julia Survey Results",
  "abstract": "A presentation on the results of the 2019 Julia Survey"
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "8AM9JC",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/favicon.jpeg",
    "name": "Roger Luo",
    "code": "VRCN8Y",
    "biography": "First year grad student from University of Waterloo.  Core member of JuliaCN, the Julia localization org in China. Core member of QuantumBFS, an open source organization for developing software for quantum physics."
   }
  ],
  "description": "## Introduction\r\n\r\nYao is an open source framework for\r\n\r\n- quantum algorithm design;\r\n- quantum [software 2.0](https://medium.com/@karpathy/software-2-0-a64152b37c35);\r\n- quantum computation education.\r\n\r\n## Motivation\r\nComparing with state of art quantum simulators, our library is inspired by quantum circuit optimization.\r\nVariational quantum optimization algorithms like quantum circuit Born machine ([QCBM](https://arxiv.org/abs/1804.04168)), quantum approximate optimization algorithm ([QAOA](http://arxiv.org/abs/1411.4028)), variational quantum eigensolver ([VQE](https://doi.org/10.1038/ncomms5213)) and quantum circuit learning ([QCL](http://arxiv.org/abs/1803.00745)) et. al. are promising killer apps on a near term quantum computers.\r\nThese algorithms require the flexibility to tune parameters and have well defined patterns such as \"Arbitrary Rotation Block\" and \"CNOT Entangler\".\r\n\r\nIn Yao, we call these patterns \"blocks\". If we regard every gate or gate pattern as a \"block\", then the framework can\r\n\r\n* be flexible to dispatch parameters,\r\n* cache matrices of blocks to speed up future runs,\r\n* allow hierarchical design of quantum algorithms\r\n\r\nThanks to Julia's duck type and multiple dispatch features, user can\r\n\r\n* easily **extend** the block system by overloading specific interfaces\r\n* quantum circuit blocks can be dispatched to some **special method** to improve the performance in specific case (e.g. customized repeat block of H gate).\r\n\r\n## Features\r\n\r\nYao is a framework that is about to have the following features:\r\n\r\n- **Extensibility**\r\n  - define new operations with a minimum number of methods in principle.\r\n  - extend with new operations on different hardware should be easy, (e.g GPUs, near term quantum devices, FPGAs, etc.)\r\n- **Efficiency**\r\n  - comparing with python, julia have no significant overhead on small scale circuit.\r\n  - special optimized methods are dispatched to frequently used blocks.\r\n  - double interfaces \"apply!\" and \"cache server + mat\" allow us to choose freely when to sacrifice memory for faster simulation and when to sacrifice the speed to simulate more qubits.\r\n- **Easy to Use**\r\n  - As a white-box simulator, rather than using a black box, users will be aware of what their simulation are doing right through the interface.\r\n  - **Hierarchical APIs** from **low abstraction quantum operators** to **highly abstract** circuit block objects.\r\n\r\nThe whole framework is highly **modularized**, researchers can extend this framework for different purposes.\r\n\r\n## Author\r\n\r\nThis project is an effort of QuantumBFS, an open source organization for quantum science. All the contributors are listed in the [contributors](https://github.com/QuantumBFS/Yao.jl/graphs/contributors).",
  "image": "https://pretalx.com/media/juliacon2019/images/8AM9JC/logo.png",
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T11:00:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-24T11:30:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "Yao.jl: Extensible, Efficient Quantum Algorithm Design for Humans.",
  "abstract": "Quantum computation is the future of computing. However, writing quantum program can be hard for developers living in a classical world. We developed Yao.jl to help scientists test and explore their quantum ideas in a simple way."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "RVXF7L",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Valentin Churavy",
    "code": "3C7UBC",
    "biography": "PhD student at the MIT JuliaLab, HPC enthusiast."
   }
  ],
  "description": "In this talk we will explore how to use Cassette to extract a symbolic trace from a Julia program and using that capability to prove properties of Julia programs . This also enables fuzzing and automated test-case development.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T16:55:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-25T17:05:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Concolic Fuzzing -- Or how to run a theorem prover on your Julia code",
  "abstract": "Concolic testing is a technique that uses concrete execution to create a symbolic representation of a program, which can be used to prove properties of programs or do provable exhaustive fuzzing."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "KD9RGB",
  "track": null,
  "state": "confirmed",
  "duration": 210,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/bk_small.JPG",
    "name": "Bogumił Kamiński",
    "code": "DHRPEA",
    "biography": "I am a researcher in the fields of operations research and computational social science.\r\nFor development work I mostly use Julia language.\r\n\r\nYou can find more information about me on [my personal website](http://bogumilkaminski.pl/about/) or [GitHub](https://github.com/bkamins)."
   }
  ],
  "description": "The workshop provides an overview of all major functionality provided in the [DataFrames.jl](https://github.com/JuliaData/DataFrames.jl) package. It is organized around solving several practical case-studies of working with tabular data and covers in particular:\r\n* Reading/writing tabular data, getting summary information about data.\r\n* Handling missing values and categorical data.\r\n* Standard transformations of tabular data (sorting, filtering, mutating, joining, reshaping, grouped operations, tabulating etc.).\r\n* Plotting of tabular data.\r\n* Performance considerations of using the DataFrames.jl package.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-22T13:30:00-04:00",
   "room": {
    "en": "PH 203N"
   },
   "end": "2019-07-22T17:00:00-04:00"
  },
  "submission_type": {
   "en": "Workshop (half day)"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Handling Data with DataFrames.jl",
  "abstract": "A case-study based tutorial on working with tabular data using the [DataFrames.jl](https://github.com/JuliaData/DataFrames.jl) package."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "QYQNMW",
  "track": null,
  "state": "confirmed",
  "duration": 210,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/huda_and_jane.jpg",
    "name": "Jane Herriman",
    "code": "9KD7FC",
    "biography": "Jane Herriman is a PhD student at the California Institute of Technology, an enthusiastic Julia user, a JuliaCon organizer, and a board member at NumFOCUS. She has delivered about 50 Julia tutorials."
   },
   {
    "avatar": null,
    "name": "Huda Nassar",
    "code": "UDMYCM",
    "biography": "Huda Nassar is Ph.D. candidate in the Computer Science department at Purdue University. \r\nHer research focuses on large scale network science and she is an active user of Julia. She is the author of MatrixNetworks.jl and had delivered multiple Julia tutorials (at places such as PyData 2016, and Purdue WiDS 2018)."
   }
  ],
  "description": "We will kick off this tutorial with an introduction to Julia, which should be accessible to anyone with technical computing needs and some exposure to another language. In the first part of the tutorial, we will cover Julia’s syntax, design paradigm, performance, basic plotting, and interfaces to other languages. We hope to show you why Julia is special, demonstrate how easy Julia is to learn, and get you writing your first Julia programs. In the second part of this tutorial, we will introduce you to data science tools for data management and machine learning algorithms and then delve into topics in performance optimization such as type stability and profiling. We will end this tutorial by going over the parallel computing infrastructure in Julia.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-22T08:30:00-04:00",
   "room": {
    "en": "PH 111N"
   },
   "end": "2019-07-22T12:00:00-04:00"
  },
  "submission_type": {
   "en": "Workshop (half day)"
  },
  "resources": [],
  "do_not_record": true,
  "title": "Excelling at Julia: basics and beyond",
  "abstract": "This tutorial targets both new and moderately experienced Julia users. After covering the basics and tools for data science, we will delve into topics such as memory management, type stability, and profiling."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "8WT7C8",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/me_eUdCiVO.jpg",
    "name": "Brandon Taylor",
    "code": "LF33LM",
    "biography": "PhD student in heterodox economics at UMass Amherst, hobbyist programmer."
   }
  ],
  "description": "LightQuery.jl is a new package for querying tabular data. I'll discuss a number of things which make it special.\r\n\r\n1) Careful use of constant propagation, so that named-tuple level operations are type stable when wrapped in a functions.\r\n2) The ability to simultaneously collect into (and iteratively widen) several sinks at once.\r\n3) Very few macros: only two, one for chaining and one for anonymizing. Compare the number of macros required for Query, DataFramesMeta, and JuliaDBMeta.\r\n4) Careful tracking and propagation of line number information.\r\n5) Huge speed-ups when sources are pre-sorted.\r\n6) Flexibility. Row-wise operations work with arbitrary containers, provided they can be indexed out of order. Column-wise operations work for anything which has propertynames.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T16:15:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-23T16:45:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "LightQuery.jl",
  "abstract": "Introducting LightQuery.jl, a new querying package which combines performance with flexibility."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "PMLSD9",
  "track": null,
  "state": "confirmed",
  "duration": 45,
  "speakers": [
   {
    "avatar": null,
    "name": "Professor Madeleine  Udell",
    "code": "9QHLWM",
    "biography": null
   }
  ],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T08:40:00-04:00",
   "room": {
    "en": "NS Room 130"
   },
   "end": "2019-07-23T09:25:00-04:00"
  },
  "submission_type": {
   "en": "Keynote"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Keynote: Professor Madeleine Udell",
  "abstract": "Madeleine Udell is Assistant Professor of Operations Research and Information Engineering\r\nand Richard and Sybil Smith Sesquicentennial Fellow at Cornell University.\r\nShe studies optimization and machine learning for large scale data analysis and control,\r\nwith applications in marketing, demographic modeling, medical informatics,\r\nengineering system design, and automated machine learning.\r\nHer research in optimization centers on detecting and exploiting novel structures\r\nin optimization problems, with a particular focus on convex and low rank problems.\r\nThese structures lead the way to automatic proofs of optimality, better complexity guarantees, and faster,\r\nmore memory-efficient algorithms. She has developed a number of open source libraries for\r\nmodeling and solving optimization problems, including [Convex.jl](https://github.com/JuliaOpt/Convex.jl),\r\none of the top tools in the Julia language for technical computing."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "JUZUDM",
  "track": null,
  "state": "confirmed",
  "duration": 45,
  "speakers": [
   {
    "avatar": null,
    "name": "Professor Heather Miller",
    "code": "9PCYTT",
    "biography": "."
   }
  ],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T08:40:00-04:00",
   "room": {
    "en": "NS Room 130"
   },
   "end": "2019-07-25T09:25:00-04:00"
  },
  "submission_type": {
   "en": "Keynote"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Keynote: Professor Heather Miller",
  "abstract": "Heather Miller is an Assistant Professor in the School of Computer Science at Carnegie Mellon,\r\nwhere she is affiliated with the Institute for Software Research. Prior to joining the faculty at CMU,\r\nProfessor Miller not only worked as a research scientist at [EPFL](https://www.epfl.ch/research/), but\r\nalso co-founded and served as the Executive Director for the [Scala Center](https://scala.epfl.ch/), a\r\nnonprofit focused on software development, education, and research surrounding the open source Scala\r\nprogramming language. She continues to work on and around Scala, while pursuing research on various\r\nflavors of distributed and concurrent computation. Some of her projects underway include programming\r\nmodels and type systems to facilitate the design of new, functional distributed systems."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "AY9C9Z",
  "track": null,
  "state": "confirmed",
  "duration": 45,
  "speakers": [
   {
    "avatar": null,
    "name": "Dr Ted Rieger",
    "code": "D7SYAD",
    "biography": "."
   }
  ],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T13:30:00-04:00",
   "room": {
    "en": "NS Room 130"
   },
   "end": "2019-07-23T14:15:00-04:00"
  },
  "submission_type": {
   "en": "Keynote"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Keynote: Dr Ted Rieger",
  "abstract": "Ted Rieger received his PhD in Chemical Engineering from Northwestern where he developed models of protein aggregation of Huntington. After graduate school, he joined Entelos, Inc in the Bay Area where he spent 6 years, developing and utilizing Quantitative Systems Pharmacology (QSP) models to understand drug development questions, primarily in the area of cardiometabolic diseases. In 2011, Ted transitioned to Pfizer’s Systems Biology Group in our CVMET Research Unit. He has been at Pfizer since then, and is now a Senior Principal Scientist in the QSP Group in Early Clinical Development.  He presently supports programs in the cardiometabolic space from early discovery through proof-of-concept."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "F8BBQW",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "JuliaCon Committee",
    "code": "M9YRTS",
    "biography": "Pontus Stenetorp (executive chair)\r\n    Jane Herriman (executive vice-chair)\r\n    Avik Sengupta (finance chair)\r\n    Adrian Salceanu (web chair)\r\n    Kevin O'Brien (social media chair)\r\n    Vijay Ivaturi (local chair)\r\n    Huda Nassar (diversity co-chair)\r\n    Nathan Daly (diversity co-chair)\r\n    Valentin Churavy (proceedings chair)\r\n    Mathieu Besançon (proceedings vice-chair)\r\n    Chris Rackauckas (program chair)\r\n    Lyndon White (program vice-chair)\r\n    Viral B. Shah\r\n    Stefan Karpinski\r\n    Cheryl Fong\r\n    Kelly Shen"
   }
  ],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T08:30:00-04:00",
   "room": {
    "en": "NS Room 130"
   },
   "end": "2019-07-23T08:40:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Opening Remarks",
  "abstract": "Welcome to Juliacon!\r\nThis opening session will let you know all the details of what is going on, and will include the important information and what to do in-case of emergencies."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "JHZRJS",
  "track": null,
  "state": "confirmed",
  "duration": 15,
  "speakers": [
   {
    "avatar": null,
    "name": "Jiahao Chen",
    "code": "GVE78J",
    "biography": null
   }
  ],
  "description": "",
  "image": "https://pretalx.com/media/juliacon2019/images/JHZRJS/jpmorgan1_dcVnHXn.png",
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T09:30:00-04:00",
   "room": {
    "en": "NS Room 130"
   },
   "end": "2019-07-24T09:45:00-04:00"
  },
  "submission_type": {
   "en": "Sponsor's Address"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Sponsor Address: J P Morgan Chase & Co.",
  "abstract": "An address from our sponsor."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "CYJRTK",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": null,
    "name": "Stefan Karpinski",
    "code": "9NNRE7",
    "biography": "Stefan is one of the co-creators of Julia and a co-founder of Julia Computing. Before Julia, he was a software engineer and data scientist at [Akamai](https://www.akamai.com), [Citrix Online](https://www.gotomeeting.com), and [Etsy](https://etsy.com). In addition to running Julia Computing, he holds a part-time appointment as a Research Engineer at New York University as part of the Moore-Sloan Data Science Environment."
   }
  ],
  "description": "",
  "image": "https://pretalx.com/media/juliacon2019/images/CYJRTK/julia1_jEsjh8N.png",
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T09:45:00-04:00",
   "room": {
    "en": "NS Room 130"
   },
   "end": "2019-07-24T09:50:00-04:00"
  },
  "submission_type": {
   "en": "Sponsor's Address"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Sponsor Address: Julia Computing",
  "abstract": "An address from one of our sponsors."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "HLLDQT",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": null,
    "name": "Clark C. Evans",
    "code": "NWXJWH",
    "biography": "Clark is a co-creator of YAML and has worked in the field of medical informatics for a dozen years working on query languages such as HTSQL.py and DataKnots.jl"
   }
  ],
  "description": "[DataKnots](https://github.com/rbt-lang/DataKnots.jl) implements an algebraic query interface of [Query Combinators](https://arxiv.org/abs/1702.08409). This algebra’s elements, or queries, represent relationships among class entities and data types. This algebra’s operations, or combinators, are applied to construct query expressions.  \r\n\r\nWe seek to prove that this query algebra has significant advantages over the state of the art:\r\n\r\n* DataKnots is a practical alternative to SQL with a declarative syntax; this makes it suitable for use by domain experts.\r\n\r\n* DataKnots' data model handles nested and recursive structures (unlike DataFrames or SQL); this makes it suitable for working with CSV, JSON, XML, and SQL databases.\r\n\r\n* DataKnots has a formal semantic model based upon monadic composition; this makes it easy to reason about the structure and interpretation of queries.\r\n\r\n* DataKnots is a combinator algebra (like XPath but unlike LINQ or SQL); this makes it easier to assemble queries dynamically.\r\n\r\n* DataKnots is fully extensible with Julia; this makes it possible to specialize it into various domain specific query languages.\r\n\r\nThis talk will provide a conceptual introduction to DataKnots.jl with applications in medical informatics.",
  "image": "https://pretalx.com/media/juliacon2019/images/HLLDQT/rabbit.png",
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T14:30:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-24T15:00:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "DataKnots.jl - an extensible, practical and coherent algebra of query combinators",
  "abstract": "DataKnots is a Julia library for querying data with an extensible, practical and coherent algebra of query combinators.  DataKnots is designed to let data analysts and other accidental programmers query and analyze complex structured data."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "LFGLXC",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": null,
    "name": "Paul Petersen",
    "code": "7LDQMH",
    "biography": null
   }
  ],
  "description": "",
  "image": "https://pretalx.com/media/juliacon2019/images/LFGLXC/intel1_HL8u1Rh.png",
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T10:00:00-04:00",
   "room": {
    "en": "NS Room 130"
   },
   "end": "2019-07-23T10:05:00-04:00"
  },
  "submission_type": {
   "en": "Sponsor's Address"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Sponsor Address: Intel",
  "abstract": "An address from one of our sponsors."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "PK738L",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": null,
    "name": "Vijay Ivaturi",
    "code": "FVEQEM",
    "biography": null
   }
  ],
  "description": "",
  "image": "https://pretalx.com/media/juliacon2019/images/PK738L/umb1_QigHLxq.jpg",
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T10:00:00-04:00",
   "room": {
    "en": "NS Room 130"
   },
   "end": "2019-07-25T10:05:00-04:00"
  },
  "submission_type": {
   "en": "Sponsor's Address"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Sponsor Address: University of Maryland",
  "abstract": "An address from one of our sponsors."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "DRP3EF",
  "track": null,
  "state": "confirmed",
  "duration": 45,
  "speakers": [
   {
    "avatar": null,
    "name": "Professor Steven G Johnson",
    "code": "BXHDXJ",
    "biography": null
   }
  ],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T08:40:00-04:00",
   "room": {
    "en": "NS Room 130"
   },
   "end": "2019-07-24T09:25:00-04:00"
  },
  "submission_type": {
   "en": "Keynote"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Keynote: Professor Steven G Johnson",
  "abstract": "Steven G. Johnson is a Professor of Applied Mathematics and Physics at MIT,\r\nwhere he joined the faculty in 2004 and previously received a PhD in physics (2001)\r\nand BS degrees in physics, mathematics, and computer science (1995).\r\nHe has a long history of contributions to scientific computation and software,\r\nincluding the [FFTW](http://www.fftw.org) fast Fourier transform library (for which he co-received\r\nthe 1999 J. H. Wilkinson Prize) and many other software packages.\r\nHe has been using, contributing to, and teaching with Julia since 2012.\r\nHe created and maintains blockbuster Julia packages that you may have heard of:\r\n[PyCall](https://github.com/JuliaPy/PyCall.jl) and [IJulia](https://github.com/JuliaLang/IJulia.jl)\r\n(and Julia’s [FFTW bindings](https://github.com/JuliaMath/FFTW.jl), of course).\r\n\r\nProfessor Johnson's professional research concerns wave-matter interactions\r\nand electromagnetism in media structured on the wavelength scale (“nanophotonics”),\r\nespecially in the infrared and optical regimes. He works on many aspects of the theory,\r\ndesign, and computational modeling of nanophotonic devices, both classical and quantum.\r\nHe is also a coauthor on over 200 papers and over 30 patents in this area,\r\nincluding the textbook *Photonic Crystals: Molding the Flow of Light*."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "LR9FW9",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/selfie_iceskating_2017.png",
    "name": "Tom Kwong",
    "code": "7U88NM",
    "biography": "Tom Kwong (github: tk3369) specializes in the financial services domain and currently works at Western Asset Management Company as a Software Engineering Manager"
   }
  ],
  "description": "Western Asset is a fixed income asset manager.  We recently replaced the portfolio risk aggregation process with a Julia implementation, and the run-time performance has improved tremendously.  This talk will focus on system architecture, performance optimization, and deployment to a Docker swarm environment.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T17:25:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-23T17:35:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "High-Performance Portfolio Risk Aggregation",
  "abstract": "We will talk about how a risk management use case got sped up ~150x using multi-core parallel computing techniques in a Docker environment."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "SSNXAP",
  "track": null,
  "state": "confirmed",
  "duration": 45,
  "speakers": [
   {
    "avatar": null,
    "name": "Dr Steven  Lee",
    "code": "SANSCS",
    "biography": null
   }
  ],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T13:30:00-04:00",
   "room": {
    "en": "NS Room 130"
   },
   "end": "2019-07-25T14:15:00-04:00"
  },
  "submission_type": {
   "en": "Keynote"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Keynote: Dr Steven Lee",
  "abstract": "Steven Lee is an Applied Mathematics Program Manager for Advanced Scientific Computing\r\nResearch (ASCR) within the Department of Energy (DOE), Office of Science. Most recently, Steven and an organizing\r\ncommittee issued a [brochure](https://www.osti.gov/biblio/1484362) and [workshop report](https://www.osti.gov/biblio/1478744)\r\non Scientific Machine Learning: Core Technologies for Artificial Intelligence.\r\nHe has also been an ASCR Program Manager within the Scientific Discovery through Advanced Computing program\r\n([SciDAC-3](https://www.scidac.gov/) Institutes)\r\nfor the projects: [FASTMATH](https://science.energy.gov/~/media/ascr/pdf/research/scidac/FASTMath-overview.pdf)\r\n- Frameworks, Algorithms and Scalable Technologies for Mathematics; and\r\n[QUEST](https://science.energy.gov/~/media/ascr/pdf/research/scidac/QUEST-overview.pdf)\r\n- Quantification of Uncertainty for Extreme-Scale Computations. Before joining the DOE, Steven was a\r\ncomputational scientist at Lawrence Livermore National Laboratory and Oak Ridge National Laboratory.\r\nHe has also been a visiting Assistant Professor in the Department of Mathematics at MIT. He has a Ph.D.\r\nin Computer Science (UIUC) and B.S. in Applied Mathematics (Yale)."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "7RPM7G",
  "track": null,
  "state": "confirmed",
  "duration": 60,
  "speakers": [
   {
    "avatar": null,
    "name": "Vijay Ivaturi",
    "code": "FVEQEM",
    "biography": null
   }
  ],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T14:30:00-04:00",
   "room": {
    "en": "BoF: Room 353"
   },
   "end": "2019-07-25T15:30:00-04:00"
  },
  "submission_type": {
   "en": "Birds of Feather"
  },
  "resources": [],
  "do_not_record": true,
  "title": "Julia in Healthcare",
  "abstract": "This session is for gathering the various groups interested in Julia for healthcare purposes. Pharmacometrics, healthcare-focused biological research, and the translation of software to practice will be discussed."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "PKLBXV",
  "track": null,
  "state": "confirmed",
  "duration": 45,
  "speakers": [
   {
    "avatar": null,
    "name": "Arch D. Robison",
    "code": "ZCPTDC",
    "biography": null
   }
  ],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T13:30:00-04:00",
   "room": {
    "en": "NS Room 130"
   },
   "end": "2019-07-24T14:15:00-04:00"
  },
  "submission_type": {
   "en": "Keynote"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Keynote: Arch D. Robison",
  "abstract": "Arch D. Robison is a Principal Systems Software Engineer at NVIDIA, where he works\r\non [TensorRT](https://developer.nvidia.com/tensorrt), NVIDIA's platform for high-performance\r\ndeep-learning inference. He was the lead developer for KAI C++, the original architect of Intel\r\nThreading Building Blocks, and one of the authors of the book *Structured Parallel Programming:\r\nPatterns for Efficient Computation*. Arch contributed type-based alias analysis and vectorization\r\nsupport to Julia, including the original implementation of [SIMD in Julia 0.3](https://software.intel.com/en-us/articles/vectorization-in-julia). He's used Julia to generate [x86 assembly language](https://software.intel.com/en-us/articles/vectorization-in-julia) for a Go\r\nimplementation of his video game *Frequon Invaders*. He also took 2nd place in AI Zimmermann's contest\r\n&quot;Delacorte Numbers&quot; [using Julia exclusively](https://software.intel.com/en-us/articles/computing-delacorte-numbers-with-julia). He has 21 patents and an Erd&ouml;s number of 3."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "MA9N8R",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/profile.JPG",
    "name": "Cameron Pfiffer",
    "code": "N7PZHP",
    "biography": "I am a developer for Turing, as well as a finance PhD student at the University of Oregon."
   }
  ],
  "description": "During the course of the talk, I will introduce Turing's modeling syntax, some typical workflows, and examples of how Turing integrates with notable Julia packages such as Flux.jl or DifferentialEquations.jl. Additionally, I hope to present the status on some of the Julia Summer of Code projects, which may include Variational Inference or greater Gaussian processes integration with Stheno.jl, among others.",
  "image": "https://pretalx.com/media/juliacon2019/images/MA9N8R/logo.png",
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T15:45:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-25T16:15:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "Turing: Probabalistic Programming in Julia",
  "abstract": "Turing is a probabilistic programming language written in Julia. This talk will introduce Turing and its tooling ecosystem, as well as go over some introductory tutorials."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "BY7ZUX",
  "track": null,
  "state": "confirmed",
  "duration": 40,
  "speakers": [],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T10:20:00-04:00",
   "room": {
    "en": "Other"
   },
   "end": "2019-07-23T11:00:00-04:00"
  },
  "submission_type": {
   "en": "Break"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Morning break",
  "abstract": "A break for coffee"
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "NS3ZQK",
  "track": null,
  "state": "confirmed",
  "duration": 15,
  "speakers": [],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T15:30:00-04:00",
   "room": {
    "en": "Other"
   },
   "end": "2019-07-25T15:45:00-04:00"
  },
  "submission_type": {
   "en": "Break"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Short break",
  "abstract": "A short break between sessions."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "BZSMMV",
  "track": null,
  "state": "confirmed",
  "duration": 15,
  "speakers": [],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T15:30:00-04:00",
   "room": {
    "en": "Other"
   },
   "end": "2019-07-23T15:45:00-04:00"
  },
  "submission_type": {
   "en": "Break"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Short break",
  "abstract": "A short break between sessions"
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "PEY7CR",
  "track": null,
  "state": "confirmed",
  "duration": 15,
  "speakers": [],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T15:30:00-04:00",
   "room": {
    "en": "Other"
   },
   "end": "2019-07-24T15:45:00-04:00"
  },
  "submission_type": {
   "en": "Break"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Short break",
  "abstract": "A short break between sessions"
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "PSSWXL",
  "track": null,
  "state": "confirmed",
  "duration": 210,
  "speakers": [
   {
    "avatar": null,
    "name": "David P. Sanders",
    "code": "TJJRTG",
    "biography": "Professor at the National University of Mexico.\r\n\r\nHas been using Julia since early 2014.\r\n\r\nMain co-author of the JuliaIntervals suite of packages.\r\n\r\nHas given Julia tutorials all over the world, some of which are available on YouTube and have over 100,000 views."
   }
  ],
  "description": "In this workshop, we will explore two of the more advanced topics that make Julia special: types and metaprogramming.\r\n\r\nWe will start off by looking at different uses of *types* as a glue in a scientific programming application: implementing a new arithmetic (automatic differentiation) and dispatch-based design.\r\n\r\nIn the second half, we will look at metaprogramming: how to get inside a Julia expression tree and apply that to write macros and \"domain-specific languages\".\r\n\r\nThis workshop is suitable for people who are comfortable with basic usage of Julia and wish to explore the language in more depth.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-22T08:30:00-04:00",
   "room": {
    "en": "PH 211N"
   },
   "end": "2019-07-22T12:00:00-04:00"
  },
  "submission_type": {
   "en": "Workshop (half day)"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Intermediate Julia for Scientific Computing",
  "abstract": "This is a workshop aimed at people who already know basic Julia usage and wish to explore some more advanced topics that make Julia special, namely defining and using types, and metaprogramming."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "KDBXKD",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": null,
    "name": "David P. Sanders",
    "code": "TJJRTG",
    "biography": "Professor at the National University of Mexico.\r\n\r\nHas been using Julia since early 2014.\r\n\r\nMain co-author of the JuliaIntervals suite of packages.\r\n\r\nHas given Julia tutorials all over the world, some of which are available on YouTube and have over 100,000 views."
   }
  ],
  "description": "We will give an overview of the suite of inter-related packages making up the `JuliaIntervals` organization. These are package which use **set calculations** to solve nonlinear equations, minimize nonlinear functions, and solve ordinary differential equations with results that are (in principle, modulo coding errors!) *guaranteed* to be correct. \r\n\r\nThe underlying technique for calculating with sets is **interval arithmetic**. Here, mathematical operations, such as `x -> x^2` and `x + y` are defined on sets, represented as intervals of all real numbers between two endpoints. By defining these operations carefully, we can guarantee that `f(X)` is guaranteed to contain `f(x)` for all `x` in the set `X`, even though we use floating-point arithmetic for the calculations.\r\n\r\nA key technique is **interval contraint propagation**, which allows us to calculate enclosures of the *inverse* of a given function. We will show how this can accelerate optimisation and root finding using interval methods.\r\n\r\nThe presentation will be based on practical applications.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T11:00:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-25T11:30:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "Interval methods for scientific computing in Julia",
  "abstract": "We will show how interval constraint propagation can give a guaranteed description of feasible sets satisfied by nonlinear inequalities via contractors. This technology can be applied to speed up guaranteed global optimization and root finding."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "ZCWD9M",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/index.png",
    "name": "Simon Danisch",
    "code": "JSJDXE",
    "biography": "I've been passionate about graphics, machine learning, scientific computing and computer graphics from an early age!\r\nAfter graduating from Cognitive Science, I was able to follow that passion by directly working for the Julia MIT team! As part of my work, I've created [Makie.jl](https://github.com/JuliaPlots/Makie.jl/),  [GPUArrays.jl](https://github.com/JuliaGPU/GPUArrays.jl), [PackageCompiler](https://github.com/JuliaLang/PackageCompiler.jl) and many other packages in the area of graphics, file-io and gpu acceleration.\r\nNowadays, I work for [Nextjournal](http://nextjournal.com/), where I'm in charge of the Julia integration, outreach and interactive plotting."
   }
  ],
  "description": "",
  "image": "https://pretalx.com/media/juliacon2019/images/ZCWD9M/Screenshot_from_2019-02-25_19-16-22.png",
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T17:05:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-23T17:35:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "A Showcase for Makie",
  "abstract": "Makie is a new plotting library written a 100% in Julia.\r\nIt offers a GPU accelerated drawing backend that can draw huge amounts of data at interactive speeds.\r\nOther backends for SVG, PDF and the Web are available as well, so Makie can be used in a many different scenarios.\r\nThis talk will give an overview of how Makie works and will present the most outstanding plotting examples from the areas of Interactivity, Data Science, Geology and Simulations."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "RUYDYR",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Dominique Luna",
    "code": "NCQPCS",
    "biography": "Dominique is a software engineer currently travelling and working on open source projects. Prior to that he worked developed educational content and simulators for Udacity's Self Driving Car and Autonomous Flight programs. He enjoys, in so specific order - cold showers, drinking coffee, doing handstands and petting animals."
   }
  ],
  "description": "Formatting code has recently gained significant trackion amongst the programming community. The most notable\r\nformatters being [gofmt](https://golang.org/cmd/gofmt/) (Go), [remft](https://reasonml.github.io/) (Reason/Ocaml), and [prettier](https://prettier.io/) (JS/CSS/HTML,etc). In this talk I'll present\r\nJulia's own formatter, which formats Julia code into a canonical, width-aware output. I'll go over:\r\n\r\n* Why you should format your code.\r\n* How the Julia formatter works and how you can use it in your workflow.\r\n* Lots of demos showing beautifully formatted code!",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T15:10:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-23T15:20:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Formatting Julia",
  "abstract": "Ever wish your code automatically beautiful? Tired of spacing out commas, wrangling parenthesis and indenting? Julia's formatter can do all this and more! Come find out how to use it your everyday workflow."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "BXVHJV",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Sungwoo Jeong",
    "code": "NNETSD",
    "biography": "Doctoral student in Department of Mathematics at MIT."
   },
   {
    "avatar": null,
    "name": "Ranjan Anantharaman",
    "code": "AZXJH3",
    "biography": "PhD Student at MIT"
   }
  ],
  "description": "Sparse matrices arising from structured grids generally possess rich structure, which is amenable to GPU-parallelism. We implemented the DIA format, one of the most primitive sparse matrix storage formats, in Julia. BLAS routines are implemented on DIA format with GPU using `CUDAnative.jl` and `CuArrays.jl`. We also present Geometric Multigrid(GMG) preconditioner, implemented on GPU using DIA format and solve large ill-conditioned systems. Julia allows users to write generic code, which allows us to exploit blocked structure that arises from higher degrees of freedom. We benchmark and verify against the SPE10 problem, a standard oil reservoir simulation benchmark.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T17:05:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-23T17:15:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Generic Sparse Data Structures on GPUs",
  "abstract": "Sparse linear operators that arise from structured grids often tend to have rich structure. We present a feature rich yet simple DIAgonal format (DIA), which also supports blocked and GPU arrays, as well as Algebraic Multigrid (AMG) preconditioners. We present this rich framework of tools to solve large oil reservoir simulations."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "RMNXL7",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/index.png",
    "name": "Simon Danisch",
    "code": "JSJDXE",
    "biography": "I've been passionate about graphics, machine learning, scientific computing and computer graphics from an early age!\r\nAfter graduating from Cognitive Science, I was able to follow that passion by directly working for the Julia MIT team! As part of my work, I've created [Makie.jl](https://github.com/JuliaPlots/Makie.jl/),  [GPUArrays.jl](https://github.com/JuliaGPU/GPUArrays.jl), [PackageCompiler](https://github.com/JuliaLang/PackageCompiler.jl) and many other packages in the area of graphics, file-io and gpu acceleration.\r\nNowadays, I work for [Nextjournal](http://nextjournal.com/), where I'm in charge of the Julia integration, outreach and interactive plotting."
   }
  ],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T17:25:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-25T17:35:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "PackageCompiler",
  "abstract": "With PackageCompiler, one can ahead of time compile binaries for Julia packages. This includes the ability to create an executable for a  Julia script.\r\nIn this talk, I will give a short overview of how PackageCompiler works and how it can be used to ship your Julia package or eliminate JIT overhead."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "JYLQ8H",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Matthew Guttenberg",
    "code": "ERXCSN",
    "biography": "Matt is a second year Ph.D. student under Venkat Viswanathan studying the dynamics of batteries as they relate to systems. He has been involved with numerous projects including how platooning, convoying of trucks, affects the energy requirements of electric semi-trucks, creating a charger placement algorithm called INCEPTS that hinges on the coupling of battery dynamics and vehicle dynamics as well as the locality of the simulation including weather, traffic flow, etc. Matt got his undergraduate degrees in Mechanical Engineering and Energy Engineering from the University of California at Berkeley and has had numerous internships in industry with companies such as SunPower."
   },
   {
    "avatar": null,
    "name": "Shashank Sripad",
    "code": "FLHAXT",
    "biography": null
   },
   {
    "avatar": null,
    "name": "Venkat Viswanathan",
    "code": "3QFYS7",
    "biography": null
   },
   {
    "avatar": "https://pretalx.com/media/avatars/headshot_copy.jpg",
    "name": "William L Fredericks",
    "code": "DMTTYC",
    "biography": "I am a researcher in the Viswanathan group at Carnegie Mellon University."
   }
  ],
  "description": "The particular battery model employed in this application predicts the voltage, temperature, state-of-charge, and degradation (i.e. lithium lost due to aging factors). Due to the complex interactions among these properties --- along with other dynamic, codependent cell properties --- the behavior of the cell over the course of an arbitrary load cannot be accurately characterized from an initial state without simulating these interactions over time. \r\n\r\nAs a result, the model implementation discretely progresses the cell through discharge and charge using a time-step of 2 seconds, predicting forward the state properties. The only time-dependent input is a load profile, which can come in the form of the power over time or current over time associated with the discharge due to the load and charging protocol. Beyond that, user inputs are only required for the initial cell state.  \r\n\r\nLooking at an individual step, the mole fraction of lithium in different parts of the cell is found using either the initial conditions or the prediction from a prior step. Calculating the open circuit potential for both the anode and cathode depends on these mole fractions and the current cell temperature. Following this step the mole fractions for the next state are calculated by approximating their rate of change, which relies on the input current, and multiplying the rate by the 2-second time-step. The state-of-charge for the next step is also calculated at this point. \r\n\r\nThe cell voltage depends on a set of overpotentials on top of the open circuit potential already estimated. As with the mole fractions, these come from initial conditions or a previous step. To predict the overpotentials for the next state, properties from the current state are used to calculate the current rate of change, which is then multiplied by the time-step. Temperature is predicted for the next state in a similar manner, as is the cell voltage. \r\n\r\nThe computational challenge derives in part from the vast parameter space necessary to characterize the model to a real cell based on testing data. The model depends on roughly 20 parameters for a single discharge-charge cycle to predict the state over time. On top of this, keeping track of cell degradation requires an additional 5 parameters. \r\n\r\nWorking from the state-of-charge model described above, a state-of-health model can be set up using these additional parameters and running the discharge model for hundreds of cycles, updating the input parameters at the beginning of each cycle. At each state during an individual cycle, the amount of lithium lost either to reactions with the electrolyte or isolation into inactive lithium metal is added to a running total for the cycle. After a cycle completes, this total is removed from the initial lithium available to the cell. Resistance and diffusivity also change over multiple cycles, and the contribution to their decay is also maintained as a running total within each cycle.\r\n\r\nSince local minima are pervasive in this parameter space, and error-minimizing strategies are too strongly influenced by initial guesses, a Monte Carlo implementation is necessary to properly train the model. This becomes prohibitively expensive computationally within Matlab, where the model was first implemented, because each cycle lasts for up to 10,000 seconds, and up to 2,000 cycles can be required to compare the aging model to the available aging data. \r\n\r\nThe search space defined by the parameters requires that the Monte Carlo be able to perform several thousand iterations. Under the Matlab implementation, each Monte Carlo iteration would take approximately 0.03 seconds. This means that the algorithm can do 1 million iterations in 500 minutes or about 8 hours. While this seems sufficient, there are 20 parameters which means that on average, there are only 50,000 changes to each variable which is likely not enough iterations per variable to properly sample the space. In addition, more complex Monte Carlo models such as the Hamilton Monte Carlo take significantly more time to run, thus limiting the number of iterations that can be run.\r\n\r\nBy implementing the same code in Julia, the algorithm got a significant speed up in addition to other benefits. Compared to the Matlab implementation, the Julia implementation had one Monte Carlo iteration complete in about 0.003 seconds. This means that there was a 10X speed up, allowing for 10X more iterations to be completed in the same time. Thus, in about 8 hours, 10 million Monte Carlo iterations could be performed. In addition, Julia enabled the code to be run in parallel on Arjuna, a high-performance computing cluster at Carnegie Mellon University. This means that in 8 hours, several of these algorithms can be run in parallel in which each performs a phase space search using 10 million iterations. Since each algorithm has enough iterations to properly sample the space, the minimum error found from the collection of Monte Carlo simulations can be assumed to be the global minimum of the search space. The large amount of Monte Carlo iterations also allows for the algorithm to use a simulated annealing function to allow the algorithm to not get stuck in local minima.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T11:50:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-24T12:00:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Julia for Battery Model Parameter Estimation",
  "abstract": "High-fidelity battery modeling requires the estimation of numerous physical parameters in order to properly capture the physics of the electrochemical, thermodynamic and chemical processes that underlie the system. Using Julia, the parameters for this model were able to be estimated by speeding up the code such that a Markov Chain Monte Carlo approach (Hamiltonian Monte Carlo) could be used, combined with a high-performance computing cluster, to sample the vast search domain and reach the global error minima."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "QFEHQS",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": null,
    "name": "James Fairbanks",
    "code": "WPZLWJ",
    "biography": "James has been developing graph theory and numerical software in julia since v0.2. He works in the JuliaGraphs ecosystem and is a research engineer at the Georgia Tech Research Institute, where he leads projects in both fundamental and applied research in computational science and engineering."
   },
   {
    "avatar": null,
    "name": "Christine R Herlihy",
    "code": "KW8LCP",
    "biography": null
   }
  ],
  "description": "SemanticModels is a system for extracting semantic information from scientific code and reconciling it with conceptual descriptions to automate machine understanding of scientific ideas. We represent the connections between elements of code (variables, values, functions, and expressions) and elements of scientific understanding (concepts, terms, relations), to facilitate several metamodeling tasks, including model augmentation, synthesis, and validation. We show how SemanticModels can be used to augment scientific workflows in the epidemiological domain. \r\n\r\nSemanticModels builds on such great Julia packages as Cassette, Flux, DifferentialEquations, and LightGraphs. It conducts static and dynamic analysis of programs to increase the productivity of scientist-developers. SemanticModels is a complimentary technology to the modeling languages like ModelingToolkit.jl and other DSLs used within the DiffEq ecosystem.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T14:30:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-24T15:00:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "SemanticModels.jl: not just another modeling framework",
  "abstract": "SemanticModels.jl is a library for analyzing scientific and mathematical models written in julia. We apply techniques from program analysis to understand and manipulate scientific modeling code. This allows you to write programs that write novel models."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "WJZJXS",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Valentin Churavy",
    "code": "3C7UBC",
    "biography": "PhD student at the MIT JuliaLab, HPC enthusiast."
   }
  ],
  "description": "Efficient performance engineering for Julia programs heavily relies on understanding the result of type-inference on your program, type-inference as process is sensitive to local information or call-context. Many Julia users use the information provided by `@code_typed` to analyse the behaviour of type-inference on *a* function. This method becomes cumbersome and inefficient with deeply nested programs where the user needs to reconstruct local information to inspect called methods. This talk introduces a tool that streamlines this process and allows users to take a static walk through their dynamic program. It simplifies the performance engineering process and is capable of handling code that uses tasks, threads and GPUs.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T16:45:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-25T16:55:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Static walks through dynamic programs -- a conversation with type-inference.",
  "abstract": "Efficient performance engineering for Julia programs heavily relies on understanding the result of type-inference on your program, this talk will introduce a tool to have a conversation with type-inference."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "N3BKPS",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": null,
    "name": "Ethan Matlin",
    "code": "G7UDTX",
    "biography": "I’m a Senior Research Analyst at the Federal Reserve Bank of New York using Julia to estimate and forecast macroeconomic models. I’m interested in applying advances in efficient scientific computing to answer questions about the economy and improve societal well-being."
   }
  ],
  "description": "In this talk, I will present DSGE.jl’s new Sequential Monte Carlo (SMC) sampler. SMC is a method of generating draws from a posterior distribution when direct sampling is not possible. In the past, modern macroeconomists have used Random Walk Metropolis Hastings for this purpose, however as our models have become more complex, Metropolis Hastings’ shortcomings have become more apparent: the algorithm produces serially correlated draws, has difficulties characterizing multimodal distributions, is slow and unable to be parallelized, and interfaces poorly with new data arrivals. \r\n\r\nSMC resolves these problems. Instead of starting from scratch with every new piece of information, we initialize the sampling algorithm at the entire posterior distribution of an older estimation. This “online estimation” allows frequent re-estimation of our models as new data become available rather than waiting months for enough new data to justify a full re-estimation. The algorithm is fast and parallelizable, reducing runtimes from days to just hours. These massive speedups make possible estimation of a new class of heterogenous agent models (which are simply infeasible to estimate using Metropolis Hastings) and allow more rigorous forecast evaluations (by allowing us to estimate a larger suite of comparison models on different data). \r\n\r\nI will discuss lessons learned regarding parallelization and improvements we’ve made to the algorithm including parameter blocking, utilization of the Chandrasekhar recursions for likelihood evaluation, and fully-adaptive hyper-parameter tuning (allowing the algorithm to flexibly accommodate the business cycle: it spends more time exploring the distribution when economic conditions are novel than when conditions are similar to those in the past). Our SMC methods may prove useful to any Julia users who conduct Bayesian estimation, and many of our developments can also be easily applied to alternative applications. Finally, I will present comparative performance benchmarks of the algorithm in Matlab, FORTRAN, and Julia and discuss approaches we’ve taken to optimize code performance. \r\n\r\nDisclaimer: This talk reflects the experience of the author and does not represent an endorsement by the Federal Reserve Bank of New York or the Federal Reserve System of any particular product or service. The views expressed in this talk are those of the authors and do not necessarily reflect the position of the Federal Reserve Bank of New York or the Federal Reserve System. Any errors or omissions are the responsibility of the authors.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T15:00:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-24T15:30:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "“Online” Estimation of Macroeconomic Models",
  "abstract": "Medium-large Dynamic Stochastic General Equilibrium models such as those used for forecasting and policy analysis by central banks take a substantial amount of time to estimate using standard approaches such as Random Walk Metropolis Hastings. Our new Sequential Monte Carlo sampler in DSGE.jl makes it possible to estimate DSGE models in parallel, reducing computational time, and “online,” that is efficiently including new data in the estimation as they become available."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "GPZYS7",
  "track": null,
  "state": "confirmed",
  "duration": 60,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/8075494.jpeg",
    "name": "Josh Day",
    "code": "3JXPXF",
    "biography": "I am a PhD statistician who enjoys programming (particularly with Julia) for difficult optimization and machine learning problems.  My niche is the intersection of statistics and computer science, which allows me to quickly translate whiteboard math into efficient programs.  During my PhD years I researched on-line algorithms for statistics (single-pass algorithms for streaming and big data), an underused paradigm where statistics/models can be updated on new batches of data without revisiting past observations (see [**OnlineStats.jl**](https://github.com/joshday/OnlineStats.jl)).  I am a [research scientist](https://www.seqstat.com/post/mm-algorithms/), [data scientist](https://www.seqstat.com/post/glmnet-tutorial/), [machine learning engineer](https://www.seqstat.com/post/juliaml/), and [software engineer](https://www.seqstat.com/post/whyjulia/). I contribute to a variety of open source data science tools, some of which can be found here: [https://github.com/joshday](https://github.com/joshday)."
   }
  ],
  "description": "Possible topics of conversation/things to work on:\r\n\r\n- JuliaDB wishlist\r\n- Utilities for feature engineering/other ML tasks\r\n- Fixing bugs\r\n- Creating benchmarks",
  "image": "https://pretalx.com/media/juliacon2019/images/GPZYS7/39419944.png",
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T14:30:00-04:00",
   "room": {
    "en": "BoF: Room 353"
   },
   "end": "2019-07-23T15:30:00-04:00"
  },
  "submission_type": {
   "en": "Birds of Feather"
  },
  "resources": [],
  "do_not_record": true,
  "title": "JuliaDB Code and Chat",
  "abstract": "JuliaDB is an analytical data framework that offers typed dataframes, parallel processing, and limited out-of-core support.  This session gives JuliaDB users and contributors the opportunity to discuss how JuliaDB works for them, tackle issues, and discuss the future of JuliaDB."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "U9XTE7",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Amita Varma",
    "code": "XLBCNG",
    "biography": "I am a to-be graduate student, and am interested in the field of health data science."
   }
  ],
  "description": "In this study, I have taken up a multi-class classification problem in order to distinguish four types of brain tumours from each other, in particular, medulloblastoma, malignant glioma, Atypical Teratoid Rhabdoid Tumor (ATRT), and normal cerebellar. The dataset describes a few thousand genes, and their numerical levels of expression in each tumour sample. The aim of the study is to predict a tumour class, given the gene expression data for that tumour. The insights from this study will be particularly useful, especially for tumours like ATRT which are difficult to diagnose. Survival rates of such types of cancer are considerably higher with an early correct diagnosis.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T11:40:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-24T11:50:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Brain Tumour Classification with Julia",
  "abstract": "I will be talking about my work on brain tumour classification using gene expression data, and how Julia as a tool aided this process."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "3BKGNU",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/paoluzzi2016.jpg",
    "name": "Alberto Paoluzzi",
    "code": "NPW7BX",
    "biography": "Alberto Paoluzzi is professor of Computer Science with the Department of Mathematics and Physics of Roma Tre University. Currently teaches Parallel and Distributed Computing, and Computational Algebraic Topology, and leads the CVD (Computational Visual Design) Lab, previously CAD-PLM Lab. He was associate professor of Computer Science with La Sapienza University of Rome from 1983 to 1993, and professor of Computer Aided Design with the Department of Informatics and Automation of Roma Tre from 2000 to 2012. He was working on graphics, geometric and solid modeling in Italy since the last seventies, and leaded the design and development of several geometrical systems, including the first solid modeler on a personal computer in 1985, and the geometric language PlaSM in more recent years. \r\nHe is a member of SIAM, ACM, the IEEE Computer Society. He was editor of Computer-aided Design journal and Computer-Aided Design and Applications. Authored 3 books, and more than 120 peer-reviewed papers on international journals and conferences. In 2017 was awarded from SMA (Solid Modeling Association) the honorific title of Pioneer of Solid Modeling."
   }
  ],
  "description": "This approach to computation of space arrangements may be used in disparate subdomains of geometric and visual computing, including geo-mapping, computer vision, computer graphics, medical imaging, geometric and solid modeling, and finite elements. In all such domains one must compute incidences, adjacencies and ordering of cells, generally using disparate and often incompatible data structures and algorithms.  E.g., most of earlier algorithms for space decomposition and Boolean operations work with data structures optimized for selected classes of geometric objects. \r\nConversely, we introduce a computational architecture based only on linear algebra with sparse arrays and basic matrix operations. Therefore our formulation, cast in terms of (co)chain complexes of (co)boundary maps, may be applied to very different geometric objects, ranging from solid models to engineering meshes, geographical systems, and biomedical images. In particular, we use rather general cellular complexes, with cells homeomorphic to polyhedra, i.e., to triangulable spaces, and hence possibly non convex and with holes.   \r\nThe main stage of our computational pipeline operates independently on each 2-cell of the input data sets, according to an embarrassingly parallel data-driven approach. It is remarkable that the approach works with collections of 2-manifolds with- or without-boundary, sets of non-manifolds, sets of 3-manifolds, etc., and not only with triangle meshes. \r\nExtending this approach to Boolean solid operations is straightforward. Among other strong points we cite: the compact representation of cellular complexes; the combinable nature of maps, allowing for multiple queries about the local topology, by a single matrix multiplication; the parallel fragmentation of input cells empowered by cell congruence; and what we call \"topological gift wrapping\" algorithm.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T11:40:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-25T11:50:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Computational topology and Boolean operations with Julia sparse arrays",
  "abstract": "This talk introduces computational topology algorithms to generate the 2D/3D space partition induced by a collection of 1D/2D/3D geometric objects. Methods and language are those of basic geometric and algebraic topology. Only sparse arrays are used to compute spaces and maps (the chain complex) from dimension zero to three."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "YPGRDD",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/bk_small.JPG",
    "name": "Bogumił Kamiński",
    "code": "DHRPEA",
    "biography": "I am a researcher in the fields of operations research and computational social science.\r\nFor development work I mostly use Julia language.\r\n\r\nYou can find more information about me on [my personal website](http://bogumilkaminski.pl/about/) or [GitHub](https://github.com/bkamins)."
   }
  ],
  "description": "[Timelineapp.co](https://timelineapp.co) is a platform that supports financial planners in analysis of different retirement income strategies. It interactively allows a user to specify the desired retirement income management plan and performs its backtesting to verify its profitability and risk profile. It shows the impact of asset allocation decisions, rebalancing, fees, and taxes and it prepares clients for market ups and downs.\r\n\r\nThe legacy development process at Timelineapp was that quantitative analysts specified application logic using Matlab and next software developers translated it to Elixir code that was deployed to production.\r\n\r\nAs the application complexity increased, even trying to squeeze out maximum performance from the legacy technology stack, the team faced the challenge that the response time per one financial scenario backtesting query would grow up to around 40 seconds. This was clearly not acceptable for an on-line application. Facing performance bottleneck  the team researched different alternatives, did some benchmarks, and picked Julia. After migrating the code, it was possible to cut the time to response down to 0.6 second per query.\r\n\r\nAnother benefit of moving to Julia was a dramatic simplification of the development process. In the past Matlab code had to be translated to Elixir. That was quite cumbersome and many times things got lost in translation from one programming language to the other. Now both, the quantitative analysts and the developers, write Julia. This way the code has less bugs and the time from idea and experimental calculations (by the quantitative analysts team) to deployment to production (by the software development team) is much shorter and agile.",
  "image": "https://pretalx.com/media/juliacon2019/images/YPGRDD/timelineapp.png",
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T11:40:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-25T11:50:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "A case study of migrating Timelineapp.co to the Julia language",
  "abstract": "[Timelineapp.co](https://timelineapp.co) is an on-line platform for financial planners. Recently its core compute engine has been migrated to the Julia language. In this talk we discuss the reasons and benefits of this decision."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "LHU9UM",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Michael Droettboom",
    "code": "PYATZM",
    "biography": "Michael Droettboom is a Staff Data Engineer at Mozilla, where he builds tools to support lean and ethical data science.  He is a former lead developer of matplotlib and airspeed velocity."
   }
  ],
  "description": "Unlike the traditional data science interaction model where the web browser only acts as a front end to computation happening on a remote server, Pyodide allows the computation to happen right within the user's web browser.  This makes interactivity more performant, and allows easier sharing of notebooks without using potentially costly or privacy-violating cloud services.\r\n\r\nI hope to present this at JuliaCon as a success story in the hopes that a similar tool can be built for Julia.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T11:40:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-24T11:50:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Pyodide: The scientific Python stack compiled to WebAssembly",
  "abstract": "Pyodide is a project from Mozilla to build a performant scientific Python stack running entirely in the web browser using WebAssembly."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "FFXKCX",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Takuya Kitazawa",
    "code": "H7JDBW",
    "biography": "[Takuya Kitazawa](https://takuti.me), a senior engineer at Arm Treasure Data, is passionate about bridging a gap between scientific theory and real-world practice in the industry. At the organization building an enterprise-grade big data analytics platform, he has been practically acted as a data scientist, technical evangelist, consultant, machine learning engineer, and software engineer through the experience of contributing to [Apache Hivemall](https://github.com/apache/incubator-hivemall/), implementing out-of-the-box ML application, presenting at conferences, and working on a variety of customer-facing opportunities. His current interest is particularly in large-scale ML and its UI/UX matter, especially in the context of recommender systems and data streams."
   }
  ],
  "description": "[Recommendation.jl](https://github.com/takuti/Recommendation.jl) allows you to easily implement and experiment your recommender systems, by fully leveraging Julia's efficiency and applicability. This talk demonstrates the package as follows.\r\n\r\nThe speaker first gives a brief overview of theoretical background in the field of recommender systems, along with corresponding Recommendation.jl functionalities. The package supports a variety of well-know recommendation techniques, including k-nearest-neighbors and matrix factorization. Meanwhile, their dedicated evaluation metrics (e.g., recall, precision) and non-personalized baseline methods are available for your experiments.\r\n\r\nNext, this talk discusses pros and cons of using Julia for recommendation. On the one hand, a number of algorithms fits well into Julia's capability of high-performance scientific computing in this field, but at the same time, it is challenging to make Julia-based recommenders production-grade at scale. The discussion ends up with future ideas of how to improve the package.\r\n\r\nWe will finally see the extensibility of the package with an example of building our own custom recommendation method. In practice, Recommendation.jl is designed to provide separated, flexible *data access layer*, *algorithm layer*, and *recommender layer* to the end users. Consequently, the users can quickly build and test their custom recommendation model with less efforts.\r\n\r\nReference: [Recommendation.jl: Building Recommender Systems in Julia](https://takuti.me/note/recommendation-julia/), an article written by the speaker.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T11:50:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-23T12:00:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Recommendation.jl: Building Recommender Systems in Julia",
  "abstract": "This talk demonstrates [Recommendation.jl](https://github.com/takuti/Recommendation.jl), a Julia package for building recommender systems. We will eventually see (1) a brief overview of common recommendation techniques, (2) advantages and use cases of their Julia implementation, and (3) design principles behind the easy-to-use, extensible package."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "3JUN8D",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Virginia Spanoudaki",
    "code": "BUQXUK",
    "biography": null
   }
  ],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T11:30:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-24T11:40:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Slow images, fast numbers: Using Julia in biomedical imaging and beyond",
  "abstract": "At MIT’s preclinical setting (Preclinical Modeling, Imaging and Testing, PMIT), the available shared biomedical imaging instrumentation, such as magnetic resonance imaging (MRI) or x-ray micro-computed tomography (microCT) scanners, produces diverse and large data sets on a daily basis. The acquisition of an image can be fast or slow depending on the acquisition protocols and whether we are interested in a 2D slice, a 3D volume or a 4D dataset over time. The time from acquisition to visualization of the image heavily depends on the size of the dataset, the image reconstruction algorithm and the computing power available. Although image acquisition and visualization are typically tied to the manufacturer of each specific platform, image quantification is more user dependent and can suffer a significant computational burden when performing non-linear mathematical operations on a pixel-by-pixel basis over millions of high-resolution images. The quantification of an image, namely the extraction of precise numerical information from the image that is representative of a biological process tied to disease and therapy, can take days to derive for users that choose high-level, easy-to-use numerical analysis software. We will present a case study of vast improvements in quantitative image processing of large preclinical MRI datasets using Julia libraries and expand on PMIT’s efforts to develop a Julia-based platform for intelligent preclinical evaluation of therapeutics from their development at bench to their visualization in a living subject."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "RH78UW",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Tim Holy",
    "code": "J9BSUH",
    "biography": "Neuroscientist and developer of the Julia language and its packages."
   }
  ],
  "description": "Revise.jl serves a dynamic bridge between the text in source files and the compiled methods in your running Julia session. To faithfully bridge these two worlds, Revise needs to understand quite a bit about code. Historically, Revise analyzed expressions written in Julia’s [surface syntax](https://docs.julialang.org/en/latest/devdocs/ast/); however, recent examples revealed a number of weaknesses in this approach. To address these limitations, starting with version 2.0 Revise has leveraged JuliaInterpreter.jl to perform its analysis of code using Julia’s internal lowered-form representation. This has resulted in dramatic improvements in the number of methods that can be tracked by their signatures, and may allow new capabilities such as discovery of block-level interdependencies. At the same time, Revise’s internal data structures have been reorganized to simplify access by other packages, resulting in a lightweight standalone package CodeTracking.jl. I will describe the motivations for these changes and the solutions enabled by the new approach, and demonstrate some of the dramatic improvements this has netted for dependent packages like Rebugger.jl.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T17:05:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-25T17:15:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Analyzing and updating code with JuliaInterpreter and Revise",
  "abstract": "Revise.jl allows you to modify code in your running Julia session. Revise was recently rewritten around JuliaInterpreter.jl and a new query interface, CodeTracking.jl, resulting in many improvements and easier access to Revise’s internal data."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "BB9VQZ",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": null,
    "name": "Tim Holy",
    "code": "J9BSUH",
    "biography": "Neuroscientist and developer of the Julia language and its packages."
   },
   {
    "avatar": null,
    "name": "Sebastian Pfitzner",
    "code": "RCTGVS",
    "biography": null
   },
   {
    "avatar": null,
    "name": "Kristoffer Carlsson",
    "code": "AS3MKE",
    "biography": "I used to be a PhD student at Chalmers University of Technology doing research in material science. Now I work for JuliaComputing, doing all kinds of different Julia stuff."
   }
  ],
  "description": "A Julia debugger, with support for breakpoints, trapping errors, and inspection of local variables, has been long desired in the Julia community. We describe an approach based on a new interpreter for Julia code, JuliaInterpreter.jl. JuliaInterpreter is able to evaluate Julia’s [lowered representation](https://docs.julialang.org/en/latest/devdocs/ast/) statement-by-statement, and thus serves as the foundation for inspecting and manipulating intermediate results. Compared with previous tools, JuliaInterpreter offers several new features, such as improved performance, the ability to evaluate top-level code, built-in support for breakpoints, and the ability to switch flexibly between compiled and interpreted evaluation. JuliaInterpreter can be used directly as a standalone interpreter, and this makes it interesting for other purposes such as exploring tradeoffs between compile-time and run-time efficiency.\r\n\r\nTo enable JuliaInterpreter’s use as a debugger, we developed three different front-ends. One is the Juno IDE, which supports graphical management of breakpoints and stepping through code in a manner integrated with its editing capabilities. In addition to Juno, there are two different console-based (REPL) interfaces. Debugger.jl offers the most powerful control over stepping, whereas Rebugger.jl emulates features of a graphical client. We will demonstrate these tools as means to access some of JuliaInterpreter’s capabilities.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T09:30:00-04:00",
   "room": {
    "en": "NS Room 130"
   },
   "end": "2019-07-23T10:00:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "Debugging code with JuliaInterpreter",
  "abstract": "We present a Julia debugger and demonstrate a variety of interfaces for accessing it. We also describe the infrastructure that provides intriguing new capabilities to the Julia ecosystem."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "9R9A7M",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": null,
    "name": "Harrison Grodin",
    "code": "YDWSNP",
    "biography": "Student at Carnegie Mellon University School of Computer Science, with an interest in programming language theory and computational symbolic mathematics. Author of Rewrite.jl and related symbolic packages. Developer of ModelingToolkit.jl and its integration into the PuMaS.jl project for pharmaceutical modeling and simulation, through the University of Maryland, School of Pharmacy, Center for Translational Medicine."
   }
  ],
  "description": "The manipulation of symbolic terms is fundamental to a variety of fields in computer science, including computer algebra, automated reasoning, and scientific modeling. Through the lens of symbolic transformations, we concisely represent and efficiently apply complex properties and equivalences. In this talk, we discuss a family of Julia packages for symbolic computation, establishing the foundations of term rewriting and showcasing extensions and applications.\r\n\r\nAfter offering a formal definition of symbolic terms, we will examine various notions from the field of term rewriting and their implementations in Rewrite.jl. We will design sets of rewrite rules that simplify algebraic expressions into unique normal forms, based on domain-specific axioms. Building on this interpretation, we finally will explore symbolic differential equations in ModelingToolkit.jl, showcasing methods for incorporating context-aware symbolic variables and techniques for enforcing mathematical invariants.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T15:45:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-25T16:15:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "Symbolic Manipulation in Julia",
  "abstract": "Symbolic terms are fundamental to a variety of fields in computer science, including computer algebra, automated reasoning, and scientific modeling. In this talk, we discuss a family of Julia packages for symbolic computation, including Rewrite.jl for term rewriting and ModelingToolkit.jl for symbolic differential equations."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "UUESUW",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Jay Dweck",
    "code": "9ZPV7Y",
    "biography": "Most recently, Jay has been consulting on large-scale cloud migrations for financial firms.  Prior to this, he served as the CTO for Arxis Capital, a wholesale market maker and high frequency proprietary trading firm.  He has also consulted for hedge funds, focusing on unified modeling of trades and positions across all asset classes, and from front to back office.\r\n\r\nJay joined Morgan Stanley in 2007 as a Managing Director and Global Head of Strategies and Technology for the Institutional Securities Group (ISG). In this capacity, Jay created Morgan Stanley Innovative Data, Environments, Analytics & Systems (IDEAS), an integrated quantitative and technology organization formed to create a sustainable, commercial advantage for Morgan Stanley by reshaping the Firm’s businesses around innovative people, processes and systems. Following the creation of IDEAS, Jay ran Morgan Stanley Strats & Modeling (MSSM), which focused on revenue generation across the breadth of the Firm’s Sales & Trading and banking businesses through the development of innovative analytics and technology.  Jay was appointed to the Firm’s Management Committee in 2009.\r\n\r\nPrior to joining Morgan Stanley, Jay was the head of Core Strategies, and then Equities Strategies for the Global Strategies Group at Goldman Sachs.  He was also the chief technology officer for Fixed Income, Equities and Financing Strategies.  He joined Goldman Sachs in 1994 in Fixed Income and became a managing director in 1997 and a partner in 2000.\r\n\r\nDuring his career Jay was president of 100% Software Solutions, a vice president at Simulation Sciences Inc., president of JSD Simulation Service Company, a member of the MIT Energy Lab and a vice president of the Merix Corporation.\r\n\r\nJay is a member of the Phi Beta Kappa, Tau Beta Pi, Sigma Xi, AIChE, ACM and MAA societies. He also serves on the board of the Perlman Music Program, and served on the MIT Chemical Engineering Visiting Committee.\r\n\r\nJay earned BS, MS and Eng degrees in Chemical Engineering and a BS in Math from the Massachusetts Institute of Technology in 1977."
   }
  ],
  "description": "Ultimate datetime is a high performance, comprehensive datatype that was developed in C, then integrated into Julia.  Ultimate datetime represents datetimes from the Big Bang through the year 100,000,000,000 with attosecond precision.  Specifiable precision and uncertainty have been implemented along with a rich set of comparison and arithmetic functions.  Leap seconds are handled properly, as is the pre-leap second atomic time period.  Local times support the full range of time zones provided in the IANA database, including proper accounting for historical time zones, as well as the varying transitions from the Julian to the Gregorian calendar around the world.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T11:40:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-23T11:50:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Ultimate Datetime",
  "abstract": "Ultimate datetime is a datetime data type, which eliminates many of the limitations and inaccuracies of the datetime datatypes generally employed in computer languages.  Ultimate datetime enables representation of datetimes from the Big Bang through to the year 100,000,000,000 with attosecond precision, while properly handling leap seconds, the full range of time zones, and accounting for precision and uncertainty."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "DJY9HU",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Jacob Quinn",
    "code": "MQ3SJP",
    "biography": "Long-time Julia fanatic; munger of data. Working on fun, automatic insight detection of data at Domo."
   }
  ],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T16:45:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-23T16:55:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "State of the Data: JuliaData",
  "abstract": "With the release of Julia 1.0, packages have raced to update and stabilize APIs. Come learn about all things current and planned for JuliaData packages, including:\r\n* DataFrames.jl\r\n* CSV.jl\r\n* Tables.jl\r\n* CategoricalArrays.jl\r\n* and others"
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "CES8P9",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Michael Reed",
    "code": "PZMKU3",
    "biography": "computational meta-linguist working on conformal geometric algebra"
   }
  ],
  "description": "The design of [Grassmann.jl](https://github.com/chakravala/Grassmann.jl) is based on the `TensorAlgebra` abstract type system interoperability from [AbstractTensors.jl](https://github.com/chakravala/AbstractTensors.jl) with a `VectorSpace` parameter from [DirectSum.jl](https://github.com/chakravala/DirectSum.jl). Abstract tangent vector space type operations happen at compile-time, resulting in a differential conformal geometric algebra of hyper-dual multivector forms.\r\n\r\nThe abstract nature of the product algebra code generation enables one to automate the extension of the product operations to any specific number field type (including symbolic coefficients with [Reduce.jl](https://github.com/chakravala/Reduce.jl) or SymPy.jl), by taking advantage of Julia's type system. With the type system, it is possible to construct mixed tensor products from the mixed tangent vector basis and its dual basis, such as bivector elements of Lie groups. `Grassmann` can be used to study unitary groups used in quantum computing by building efficient computational representations of their algebras. Applicability of the Grassmann computational package not only maps to quantum computing, but has the potential of impacting countless other engineering and scientific computing applications. It can be used to work with automatic differentiation and differential geometry, algebraic forms and invariant theory, electric circuits and wave scattering, spacetime geometry and relativity, computer graphics and photogrammetry, and much more.",
  "image": "https://pretalx.com/media/juliacon2019/images/CES8P9/grassmann.png",
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T11:50:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-25T12:00:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Geometric algebra in Julia with Grassmann.jl",
  "abstract": "The [Grassmann.jl](https://github.com/chakravala/Grassmann.jl) package provides tools for doing computations based on multi-linear algebra, differential geometry, and spin groups using the extended tensor algebra known as Grassmann-Clifford-Hestenes-Taylor geometric algebra. The primary operations are `∧, ∨, ⋅, *, ×, ⋆, ', ~` (which are the outer, regressive, inner, geometric, and cross products along with the Hodge star, adjoint, and multivector reversal operations). Any operations are truly extensible with high dimensional support for up to 62 indices and staged caching / precompilation, where the code generation enables the fairly automated task of making more definitions. The [DirectSum.jl](https://github.com/chakravala/DirectSum.jl) multivector parametric type polymorphism is based on tangent bundle vector spaces and conformal projective geometry to make the dispatch highly extensible for many applications. Additionally, interoperability between different sub-algebras is enabled by [AbstractTensors.jl](https://github.com/chakravala/AbstractTensors.jl), on which the type system is built."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "ZE9AVH",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": null,
    "name": "Cora Kingdon",
    "code": "K9QVHJ",
    "biography": "Cora is a Research Assistant at Resources for the Future where she uses the Julia software package, Mimi.jl, for Integrated Assessment Modeling of climate damages and the social cost of carbon. She is a recent graduate of UC Berkeley where she contributed to research in the Energy and Resources Group and was a co-developer of Mimi.jl."
   },
   {
    "avatar": null,
    "name": "Lisa Rennels",
    "code": "U7TFVK",
    "biography": "__"
   },
   {
    "avatar": "https://pretalx.com/media/avatars/davidanthoffsmallsquare_Me2FZ2a.jpg",
    "name": "David Anthoff",
    "code": "7JQFVF",
    "biography": "David Anthoff is an environmental economist who studies climate change and environmental policy. He co-develops the integrated assessment model FUND that is used widely in academic research and in policy analysis. His research has appeared in Science, the Journal of Environmental Economics and Management, Environmental and Resource Economics, the Oxford Review of Economic Policy and other academic journals. He contributed a background research paper to the Stern Review and has advised numerous organizations (including US EPA and the Canadian National Round Table on the Environment and the Economy) on the economics of climate change.\r\n\r\nHe is an assistant professor in the Energy and Resources Group at the University of California, Berkeley. Previously he was an assistant professor in the School of Natural Resources and the Environment of the University of Michigan, a postdoc at the University of California, Berkeley and a postdoc at the Economic and Social Research Institute in Ireland. He also was a visiting research fellow at the Smith School of Enterprise and the Environment, University of Oxford.\r\n\r\nHe holds a PhD (Dr. rer. pol.) in economics from the University of Hamburg (Germany) and the International Max Planck Research School on Earth System Modelling, a MSc in Environmental Change and Management from the University of Oxford (UK) and a M.Phil. in philosophy, logic and philosophy of science from Ludwig-Maximilians-Universität München (Munich, Germany)."
   }
  ],
  "description": "In 2016, the EPA commissioned a report from the National Academy of Sciences on research priorities for improving and updating the Social Cost of Carbon, a metric used by the federal government to account for the impacts of climate change within regulatory impact analyses. One central recommendation from the ensuing National Academies [report](https://www.nap.edu/catalog/24651/valuing-climate-damages-updating-estimation-of-the-social-cost-of) was to create a common, modular computational platform to better serve modelling work in this area.\r\n\r\nOur team created the leading (and probably only) implementation following this call to action: the [Mimi Framework](https://www.mimiframework.org/). Mimi.jl is entirely implemented in Julia. This talk will present this computational platform, discuss its application, and dive into key design considerations.\r\n\r\nThe main design constraints for Mimi.jl were that we needed something: \r\na) computationally fast,  \r\nb) simple enough that a lack of significant programming experience is not a barrier for users,\r\nc) that enables a modular work style for distributed, loosely coordinated teams, and \r\nd) that creates a transparent framework enabling easy replication of computational experiments.\r\n\r\nWe will describe in some detail how we achieved this design using a macro based domain specific language for certain parts of the framework, while at the same time exposing the full power of the Julia language to users. We will also touch on our use of a custom Julia registry as the repository for different modules that different groups can work on, allowing us to use Julia’s package manager to solve the replication problem for computational experiments. We will also discuss a large number of specific design decisions that helped us make the system easy to use for novice programmers.\r\n\r\nWe will conclude the talk with a discussion of adoption and impact of this platform. We will outline how different groups at a number of leading universities and think tanks have adopted the platform for their work and outline why we believe it will power the next generation of the US federal climate economics work in the regulatory space going forward.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T14:30:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-25T15:00:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "Mimi.jl – Next Generation Climate Economics Modeling",
  "abstract": "We will present Mimi.jl, a next generation platform for Integrated Assessment Modelling widely used in climate economics research. The talk will outline technical aspects of the platform, as well as its adoption and impact both on research at universities and in the US federal climate regulation process."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "HANGXH",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Jesse Bettencourt",
    "code": "EL3WH8",
    "biography": "Jesse Bettencourt is a graduate student in the Machine Learning group at the University of Toronto and the Vector Institute. He is supervised by David Duvenaud and Roger Grosse and teaches the senior undergraduate/graduate course on probabilistic models and machine learning."
   }
  ],
  "description": "This talk will demonstrate models described in [Neural Ordinary Differential Equations](https://arxiv.org/pdf/1806.07366.pdf) implemented in DiffEqFlux.jl, using DifferentialEquations.jl to solve ODEs with dynamics specified and trained with Flux.jl. In particular it will show how to use gradient optimization with the adjoint method to train a neural network which parameterizes an ODE for supervised learning and for Continuous Normalizing Flows. These demonstrations will be contributed to the Flux model-zoo.\r\n\r\nThe supervised learning demonstration will illustrate that neural ODEs can be drop-in replacements for [residual networks](https://arxiv.org/pdf/1512.03385.pdf) on supervised tasks such as image recognition. \r\n\r\nThe Continuous Normalizing Flow demo will show how a neural ODE, with the instantaneous change of variables, can learn a continuous transformation from tractable base distribution to a distribution over data which can be sampled from and evaluate densities under.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T16:25:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-24T16:35:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Neural Ordinary Differential Equations with DiffEqFlux",
  "abstract": "This talk will demonstrate the models described in [Neural Ordinary Differential Equations](https://arxiv.org/pdf/1806.07366.pdf) implemented in DiffEqFlux.jl, using DifferentialEquations.jl to solve ODEs with dynamics specified and trained with Flux.jl."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "WFVWES",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/3334079.jpeg",
    "name": "Tim Wheeler",
    "code": "JD3KQB",
    "biography": "Tim Wheeler is a software engineer working on flying autonomous cars at Kitty Hawk. He recently got his Ph.D. in Aeronautics and Astronautics from Stanford for research in automotive artificial intelligence and methods for validating the safety of autonomous vehicles. Tim has sent weather balloons to the edge of space, hit Space X rockets with a big hammer, and written a college-level textbook on optimization. He loves Julia and has contributed to several  METADATA packages, including PGFPlots.jl, Discretizers.jl, and CrossfilterCharts.jl."
   }
  ],
  "description": "My coauthor (Prof. Mykel Kochenderfer) and I wrote a full-length, fully-featured, academic textbook. It is full of beautiful Julia-generated figures and typeset Julia code snippets. Everything is source controlled .tex files, and everything else is generated on compile. This talk covers how we did it and why you might want to do it too.",
  "image": "https://pretalx.com/media/juliacon2019/images/WFVWES/fig_direct_nelder_mead.png",
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T15:00:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-25T15:30:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "How We Wrote a Textbook using Julia",
  "abstract": "The speaker's experience writing a full-length optimization textbook with Julia-generated figures and typeset julia code, how to all works."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "FXU7DC",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Patrick Kofod Mogensen",
    "code": "UYTBHQ",
    "biography": "Patrick Kofod Mogensen, or pkofod, has used Julia since v0.2, and contributed to various packages as well as JuliaLang itself. He is a PhD student in Economics at University of Copenhagen."
   }
  ],
  "description": "Optim, NLsolve and LsqFit are three packages in the JuliaNLSolvers organization. They have all been around from the early Julia days, and serve some basic scientific computing needs such as minimizing a function, fitting a curve and solving a system of equations. Their age means that they are widely used and well-known. However, their age also show in much of the design and abstractions that predates many of the unique and powerful features and packages in Julia.\r\n\r\nBased on my own experience as a maintainer of these packages, and learning from the discussions on mailing lists, forums, and github, I will talk about the failures of the three packages, and how a complete rewrite of the packages is the best way forward. Hopefully, my reflections and experiences can help future package writers avoid making the same mistakes over and over again.\r\n\r\nThe talk won't be heavy on the mathematical details, but will explore important things to design for from the start. Users will eventually request many of the features, but they might be difficult to retrofit, so come join the quest to find the best ways of satisfying the greedy Julia users and abusers out there!",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T11:40:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-24T11:50:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Re-designing Optim",
  "abstract": "With Julia v1.0 released, It is time to reflect on what a Julian Julia package is, and why some popular packages such as Optim is not necessarily as Julian as they can be! Based on requests from the community and own experiences, I explain some guiding principles on a complete re-write of the packages in the JuliaNLSolvers organization."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "ZDRQQA",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/fb739ca4f29b63cd15f103501aa9d82f.jpeg",
    "name": "Ramchandran Muthukumar",
    "code": "8LWZCK",
    "biography": "I am currently a Research Assistant for Prof. Madeleine Udell at Cornell University. I will be a CS PhD student at Johns Hopkins from Fall 2019. I was a 2016 Google Summer of Code Fellow under NumFocus/Julia-Opt organization where I worked on pre-solve routines for LP. \r\n\r\nI'm interested in optimization, numerical analysis and leveraging the powerful expressiveness of the Julia language in scientific research."
   }
  ],
  "description": "This work is motivated by the challenge of expensive storage in optimization problems with PDE constraints e.g. optimal flow control, full waveform inversion, optical tomography etc.\r\nThese optimization problems are characterized by PDE constraints that uniquely determine the state of a physical system for a given control. The state matrix is typically much more expensive to store than the control matrix. \r\n\r\nThe optimization algorithms effects changes in the control that move a physical system towards optimal behavior. Any first or second order algorithm requires gradient computation. As a first step we have to solve the PDE and store its solution and this is a storage bottleneck. \r\n\r\nRecently randomized algorithms have been developed for matrix approximation and Sketching is a high-performance algorithm for on-the-fly compression of matrices. We demonstrate how sketching can be used to compute approximate gradients and hessian-times-vector quantities while avoiding the storage bottleneck caused by the PDE solution. \r\n\r\nThis cutting-edge algorithmic recipe has been applied successfully for linear parabolic boundary control and optimal fluid flow. We also explore its implications for efficient adjoint computation or back-propagation.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T17:05:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-24T17:15:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Randomized Sketching for Approximate Gradients : Applications to PDE Constrained Optimization",
  "abstract": "Randomized sketching algorithms are a powerful tool for on-the-fly compression of matrices. In this talk we show how sketching can be used for approximate gradient and hessian-times-vector computations that are storage optimal.\r\nThis approach gives cutting-edge low memory algorithms to address the challenge of expensive storage in optimization problems with PDE constraints. \r\nWe also discuss implications for efficient adjoint computation/back-propagation."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "DAKCYM",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Fredrik Ekre",
    "code": "FTWNWJ",
    "biography": "I am a PhD student in computational material mechanics and use Julia both for research, procrastination and as a hobby."
   }
  ],
  "description": "Literate programming was introduced by Donald Knuth in 1984 and is described as an _explanation of the program logic in a natural language, interspersed with traditional source code_. `Literate.jl` is a simple Julia package that can be used for literate programming. The original purpose was to facilitate writing example programs for documenting Julia packages.\r\n\r\nJulia packages are often showcased and documented using \"example notebooks\". Notebooks are great for this purpose since they contain both input source code, descriptive markdown and rich output like plots and figures, and, from the description above, notebooks can be considered a form of literate programming. One downside with notebooks is that they are a pain to deal with in version control systems like git, since they contain lots of extra data. A small change to the notebook thus often results in a large and complicated diff, which makes it harder to review the actual changes. Another downside is that notebooks require external tools, like Jupyter and `IJulia.jl` to be used effectively.\r\n\r\nWith `Literate.jl` is is possible to dynamically generate notebooks from a simple source file. The source file is a regular `.jl` file, where comments are used for describing the interspersed code snippets. This means that, for basic usage, there are no new syntax to learn in order to use `Literate.jl`, basically any valid Julia source file can be used as a source file. This solves the problem with notebooks described in the previous section, since the notebook itself does not need to be checked into version control -- it is just the source text file that is needed. `Literate.jl` can also, from the _same_ input source file, generate markdown files to be used with e.g. `Documenter.jl` to produce HTML pages in the package documentation. This makes it easy to maintain both a notebook and HTML version of examples, since they are based on the same source file.\r\n\r\nThis presentation will briefly cover the `Literate.jl` syntax, and show examples of how `Literate.jl` can be used.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T15:00:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-23T15:10:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Literate programming with Literate.jl",
  "abstract": "Literate programming is described as an _explanation of the program logic in a natural language, interspersed with traditional source code_.  This presentation will describe how the `Literate.jl` package can be used for literate programming, and show how to generate multiple outputs, such as jupyter notebooks, or markdown pages, based on the same source file."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "8T3FVZ",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/me_VCAJnxO.jpg",
    "name": "Jun Tian",
    "code": "LRSECX",
    "biography": "[Jun Tian](https://tianjun.me/about) is a software engineer working in Microsoft Beijing with a broad interest in Natural Language Understanding and Reinforcement Learning."
   }
  ],
  "description": "Hanabi is a card game for two to five players. What makes Hanabi special is that, unlike most card games, players can only see their partners' hands, and not their own. In this talk, I will focus on the following three parts:\r\n\r\n1. A short introduction to Hanabi and how to implement the game in a client-server style in Julia.\r\n\r\n2. The challenges of Hanabi and some typical approaches.\r\n\r\n3. The implementation details of some state-of-the-art algorithms.\r\n\r\nI hope this talk can arouse the interest of the audiences. And get more people involved in the reinforcement learning field in Julia.",
  "image": "https://pretalx.com/media/juliacon2019/images/8T3FVZ/me.jpg",
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T15:10:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-23T15:20:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Let's Play Hanabi!",
  "abstract": "Games have been testbeds for Artificial Intelligence research for a long time. Here I will demonstrate how to play the fantastic [Hanabi card game](https://en.wikipedia.org/wiki/Hanabi_(card_game)) interactively in Julia REPL. Furthermore, I will introduce how to implement some state-of-the-art learning algorithms in pure Julia."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "QXF9AM",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": null,
    "name": "Nathan Daly",
    "code": "JP9VJF",
    "biography": "Nathan Daly is a Software Engineer at [RelationalAI](http://relational.ai). He was first introduced to the idea of contributing to JuliaLang as one small way to help fight climate change by making scientific computing a little bit easier: http://worrydream.com/ClimateChange"
   }
  ],
  "description": "Julia's ability to compile away complex logic is remarkable. Especially in recent releases, Const-propagation is a thing to behold! But we've found it can be hard to reason about _why_ some operations are compiled away (or why they aren't), and even harder to _control_ that behavior. What's more, that behavior can change as your code evolves, or Julia is updated, and it's difficult to test.\r\n\r\nIn Julia, the distinction between compile-time and runtime is deliberately muddy: compilation itself happens _during runtime_; a function may be compiled once, many times or never—it might even be compiled more times than it runs. Still, there are cases where we expect a function to be compiled once, early on, and then need it to run extremely quickly, many times, in a tight loop, where controlling the ability to move work from runtime to compile-time is critical.\r\n\r\nThis talk will explore a few such motivating cases we've seen at [RelationalAI](http://relational.ai), including in pieces of the [FixedPointDecimals.jl](https://github.com/JuliaMath/FixedPointDecimals.jl) library. We'll examine the options currently available in Julia for controlling compile-time execution, and their pros and cons, including some lessons-learned about the pain we've experienced with `@generated`. We'll study the approach modern C++ is taking to this problem, with its `constexpr` annotation. And we'll propose a few ideas for how we might add features to Julia that could increase our control over this fierce compiler.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T14:30:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-25T15:00:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "If Runtime isn't Funtime: Controlling Compile-time Execution",
  "abstract": "\"This block will compile away,\" the comments say. _But will it?_ In this talk we'll see some scenarios where controlling compile-time vs runtime execution is crucial for performance, and we'll discuss some ideas that might make this control easier in Julia."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "FXBCLP",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": null,
    "name": "Simon Byrne",
    "code": "PKSECG",
    "biography": "I started using Julia in 2012, first as a researcher in computational statistics, then as a developer at Julia Computing. I recently joined the [CliMA](https://clima.caltech.edu/) project as the lead software engineer."
   },
   {
    "avatar": "https://pretalx.com/media/avatars/headshot_-_Cropped_bmH40Nn.png",
    "name": "Charlie Kawczynski",
    "code": "E77THB",
    "biography": null
   }
  ],
  "description": "The [Climate Modeling Alliance (CliMA)](https://clima.caltech.edu/) aims to build the first Earth system model that automatically learns from both Earth observations and embedded high-resolution simulations. The goal is to build a more accurate climate model with quantified uncertainties. \r\n\r\nHigh computational performance on heterogeneous architectures, including CPUs, GPUs, and distributed computing architectures is essential for the project. The model is being developed in Julia to ensure portable performance at supercomputing scales for this ambitious scientific computing project.\r\n\r\nThis talk will give an overview of the project and its motivation. We will highlight how we’re pushing Julia to scale, including lessons learnt and challenges we are facing.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T15:00:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-25T15:30:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "The Climate Machine: A New Earth System Model in Julia",
  "abstract": "We are using Julia to develop the first Earth System Model that automatically learns from diverse data sources."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "9UWDLY",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/pic_yVJTmfP.png",
    "name": "Laurent Heirendt",
    "code": "ZPR8XY",
    "biography": "Laurent Heirendt was born in 1987 in Luxembourg City, Luxembourg (Europe). He received his BSc in Mechanical Engineering from the Ecole Polytechnique Fédérale de Lausanne, Switzerland in 2009. A year later, he received his MSc in Advanced Mechanical Engineering from Imperial College London in the UK, where his research and thesis focused on developing a general dynamic model for shimmy analysis of aircraft landing gear that is still in use today. He received his PhD in 2014 in Aerospace Science from the University of Toronto, Canada. He developed a thermo-tribomechanical model of an aircraft landing gear, which led to a patent pending design of a critical aircraft landing gear component. He then worked in industry and oversaw the structural analysis of large aircraft docking structures. \r\n\r\nLaurent currently works as a Research Associate at the Luxembourg Centre for Systems Biomedicine. His work focuses on responsible and reproducible research science and scientific computing applications using Julia. Besides his mother tongue Luxembourgish, he is fluent in English, French and German, and he is actively learning Brazilian Portuguese."
   },
   {
    "avatar": null,
    "name": "Vasco Verissimo",
    "code": "JRDSMT",
    "biography": null
   }
  ],
  "description": "Recent advances in single-cell technologies offer an unprecedented opportunity to comprehensively characterize the immune system, revealing a previously unparalleled complexity in the phenotype and function of immune cells. Mass cytometry, also known as CyTOF, was recently implemented to measure up to 40 different markers in several million single cells. A typical clinical study with hundreds of patients can therefore include billions of single cells (rows) and up to 40 markers (features).\r\nDifferent dimension reduction methods have been implemented in commercial and open-source software, mainly written in R. The machine learning algorithm FlowSOM [1] is based on the famous Kohonen Self Organising Feature Maps (SOM) [2] and has shown various advantages over other methods.\r\nHowever, all current implementations have a critical limitation on the total number of cells to be analyzed . This limitation often blocks the analysis of large-scale clinical studies with several hundred million cells. \r\nHere, we present the open-source, high-level, and high-performance package GigaSOM.jl (https://github.com/LCSB-BioCore/GigaSOM.jl), which is HPC-ready and is written to handle very large datasets without limits. Julia is the natural language of choice when it comes to performing huge-scale cytometric analyses. With the GigaSOM.jl package, the possibilities for flow cytometry analysis  are further broadened. The quality of the software package is assured using ARTENOLIS (https://artenolis.lcsb.uni.lu) [3]. Biological validation of the results will be performed on downsampled datasets by comparison to conventional implementations of the FlowSOM package and manual hierarchical analysis. \r\n\r\n*References*\r\n\r\n[1] Sofie Van Gassen, Britt Callebaut, Mary J. Van Helden, Bart N. Lambrecht, Piet Demeester, Tom Dhaene and Yvan Saeys. FlowSOM: Using self-organizing maps for visualization and interpretation of cytometry data. Cytometry A 2015, volume 87.7 (p. 636-645)\r\n[2] Kohonen T. The self-organizing map. Proc IEEE 1990;78:1464–1480\r\n[3] Heirendt, Laurent; Arreckx, Sylvain; Trefois, Christophe; Yarosz, Yohan; Vyas, Maharshi; Satagopam, Venkata P.; Schneider, Reinhard; Thiele, Ines; Fleming, Ronan M. T., ARTENOLIS: Automated Reproducibility and Testing Environment for Licensed Software, arXiv:1712.05236.",
  "image": "https://pretalx.com/media/juliacon2019/images/9UWDLY/gigaSOM-logo-talk.png",
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T17:05:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-25T17:15:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "GigaSOM.jl: Huge-scale, high-performance flow cytometry clustering in Julia",
  "abstract": "Flow cytometry clustering for several hundred million cells has long been hampered by software implementations. Julia allows us to go beyond these limits. Through the high-performance GigaSOM.jl package, we gear up for huge-scale flow cytometry analysis."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "CY3YQB",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Rory Finnegan",
    "code": "XLAWTE",
    "biography": "A software developer with an interest in computational neuroscience."
   }
  ],
  "description": "We'll start by discussing filesystem libraries for other languages (e.g., [pathlib](https://docs.python.org/3/library/pathlib.html) for Python, [Data.FilePath](https://hackage.haskell.org/package/data-filepath-2.2.0.0/docs/Data-FilePath.html) for Haskell, [Paths](https://doc.rust-lang.org/std/path/struct.Path.html) in Rust) and how such abstractions may uniquely benefit from multiple dispatch in Julia.\r\nI’ll review some examples of how we (myself and my colleagues) have used [FilePathsBase.jl](https://github.com/rofinn/FilePathsBase.jl) to simplify our application logic and avoid ambiguous code paths.\r\nFinally, we'll conclude with an open discussion around how these abstractions can be better incorporated into the larger Julia ecosystem.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T11:30:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-23T11:40:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "FilePaths: File system abstractions and why we need them",
  "abstract": "Have you ever found yourself writing code that special cases different local and remote [filesystems](https://en.wikipedia.org/wiki/File_system)? \r\nFilePath types are a great way to encapsulate filesystem specific logic and provide a common [abstraction](https://en.wikipedia.org/wiki/Abstraction_layer) for interacting with various types of paths (e.g., posix, windows, S3, FTP)."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "G9Z3AG",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Ahan Sengupta",
    "code": "A3J7CA",
    "biography": "I’m 13 years old and have a great interest in programming. I started coding in Scratch when I was 9 years old but I  now code in Python and Julia. I also presented a poster at JuliaCon 2018."
   }
  ],
  "description": "This project is a miniaturised smart house that uses a Raspberry Pi and Julia to automatically run a small model home. This smart house uses a Raspberry Pi with a Sense HAT and Explorer HAT Pro to create several functions that could be used on a real house. This includes a motion sensor that opens a door; a photoresistor that turns lights on and off and a Sense HAT taking readings and scrolling through them on an LED matrix. All these are functions which are used on houses and have been scaled down using the Raspberry Pi and the Julia Language.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T11:50:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-23T12:00:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Smart House with JuliaBerry",
  "abstract": "Hardware and software scale model of a smart house that utilises the functions of a Raspberry Pi. It has several functions that could be transferred to a full-scale model using the same hardware."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "KAMHYJ",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": null,
    "name": "Fredrik Ekre",
    "code": "FTWNWJ",
    "biography": "I am a PhD student in computational material mechanics and use Julia both for research, procrastination and as a hobby."
   }
  ],
  "description": "Julia's new package manager, Pkg, was released together with version 1.0 of the Julia language. The new package manager is a complete rewrite of the old one, and solves many of the problems observed in the old version. One major feature of the new package manager is the concept of _package environments_, which can be described as independent, sandboxed, sets of packages.\r\n\r\nA package environment is represented by a `Project.toml` and `Manifest.toml` file pair. These files keep track of what packages, and what versions, are available in a given environment. Since environments are \"cheap\", just two files, they can be used liberally. It is often useful to create new environments for every new coding project, instead of installing packages on the global level. Since the package manager modifies the current project, e.g. when adding, removing or updating packages, there is no risk for these operations to mess up other environments.\r\n\r\nThe fact that exact versions of packages in the environment is being recorded means that Julia has reproducibility built-in. As long as the `Project.toml` and `Manifest.toml` file pair is available it is possible to replicate exactly the same package environment. Some typical use cases include being able to replicate the same package environment on a different machine, and being able to go back in time and run some old code which might require some old versions of packages.\r\n\r\nIn this presentation we will discuss how environments work, how they interact with the package manager and Julia's code loading, and how to effectively use them. Hopefully you will be more comfortable working with, and seeing the usefulness of, environments after this presentation.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T11:00:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-23T11:30:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "Pkg, Project.toml, Manifest.toml and Environments",
  "abstract": "One of the major features of Julia's new package manager is _package environments_. This presentation will explain how environments work, what they are useful for and how to use them effectively."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "37VY3Q",
  "track": null,
  "state": "confirmed",
  "duration": 60,
  "speakers": [
   {
    "avatar": null,
    "name": "Chris Hill",
    "code": "W7TEDS",
    "biography": "Chris Hill is a principal researcher at MIT who works on computational science applied to large-scale ocean and Earth system modeling. He has worked in this area for nearly 30 years and has contributed to several widely used open source efforts. In collaboration with many others he is helping to develop a next generation climate model in Julia and is intrigues that for now the core distributed memory parallelism abstractions for the project will be programmed directly in MPI, despite 30 years of innovation and research exploration of parallelism paradigms."
   },
   {
    "avatar": null,
    "name": "Alan Edelman",
    "code": "LNYSC7",
    "biography": null
   },
   {
    "avatar": null,
    "name": "Lucas Wilcox",
    "code": "WE8NNS",
    "biography": null
   },
   {
    "avatar": null,
    "name": "Andreas Noack",
    "code": "JMGPUB",
    "biography": "Working on science projects at Julia Computing. Formerly post.doc. in the JuliaLab at MIT-CSAIL."
   },
   {
    "avatar": null,
    "name": "Valentin Churavy",
    "code": "3C7UBC",
    "biography": "PhD student at the MIT JuliaLab, HPC enthusiast."
   }
  ],
  "description": "This BoF is motivated in part by interesting new application development efforts that are combining high-performant scientific computing style parallelism with large scale machine learning, optimization and statistical methods. The BoF will focus on current and future directions for language and library level abstractions for large distributed parallel applications in Julia. Some projects such as [Celeste](https://juliacomputing.com/case-studies/celeste.html) and [CLiMA](https://clima.caltech.edu) are employing Julia for work that scales to tens of thousands or more parallel cores. The BoF will be a forum for starting conversations and brainstorming how Julia tools for distributed parallelism might evolve in coming years to support both portable, high-performance parallelism and productive interactivity in a relatively unified way. The BoF will include short presentations from current participants in large scale scientific computing parallel efforts using Julia, it will also include short presentations from relevant tool developers as well as an open discussion time for question and answer.  We anticipate covering a few interconnected themes and goals.\r\n\r\n**Blending in new ideas**. In the last 30 years, since the emergence of the message passing interface (MPI) parallel library standard for scientific computing, many projects have explored alternate parallelism paradigms. These alternates, which include UPC, X10, CoArray Fortran, Chapel, Hadoop, Spark, OCCA and many others, have introduced new ideas, but in scientific computing none have gained the broad traction of MPI in practice. One topic of interest for this BoF is where can the Julia language, library and meta-programming ecosystem usefully blend in some of the parallel programming ideas that have emerged in academic projects in the last 30 years.\r\n\r\n**Enabling interactivity front and center in large scale, high-performance parallelism**. Are there ways Julia might help bring some flavor of productive interactivity to the sorts of applications that have typically leveraged MPI for portable performance. Some debugging tools, from other languages, such as [ddt](https://developer.nvidia.com/allinea-ddt) and [totalview](https://www.roguewave.com/products-services/totalview) may provide models for how to interact explicitly with multiple concurrent streams of computation in a large parallel application under something of a REPL feel. Julia Distributed arrays, Channels and Cluster manager abstractions provide more implicit ways for interacting with parallel computation streams. Using existing components it is already possible to create elaborate applications that mix high-performance parallel simulation and distributed machine learning, for example, in a single workflow. This sort of workflow is emerging in many fields from plasma science to economics.  However, current programming approaches can result in a somewhat complex mix of abstractions that are not always amenable to flexible and agile exploration in an interactive environment of the sort that is Julia's hallmark.\r\n\r\n**Catalyzing activities to discover the right APIs**. The BoF will aim to catalyze conversations and energize projects looking at the next generation of Julia ecosystem tools to support high-performance, parallel scientific computing. In this realm it is likely that many of the key abstractions/APIs are likely to be discovered somewhat organically as much as designed. The BoF seeks to be inclusive to all Julia projects that may have an interest in these areas. The organizers welcome anyone interested in presenting a slide at the BoF to [contact us](mailto:christophernhill+juliacon2019@gmail.com). We plan to gather the BoF material into a post meeting document that will be openly available.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T11:00:00-04:00",
   "room": {
    "en": "BoF: Room 353"
   },
   "end": "2019-07-25T12:00:00-04:00"
  },
  "submission_type": {
   "en": "Birds of Feather"
  },
  "resources": [],
  "do_not_record": true,
  "title": "Performant parallelism with productivity and portability.",
  "abstract": "This BoF will be a forum to discuss the state of the state around performant parallelism for distributed memory programming in Julia. Performance, parallelism, productivity and portability are four P's of distributed memory parallelism that over the last 30 years have proved hard to satisfy simultaneously in a general solution. The goal of this BoF is discussion and exploration of approaches for providing performant distributed memory parallelism in Julia in ways that are portable and that reflect the productivity vision of Julia. The format will consist of a series of presentations and a discussion/Q&A section. It will look both within Julia and across other languages at the last 30 years of efforts in this space. The motivation for the BoF is that meeting the four P's well remains an unsolved problem. For now projects that seek all of performance, parallelism at scale, portability and productivity typically have to make compromises in one or more of these areas. The hoped for outcome is some shared momentum and sharing of ideas for developing Julian approaches that lessen (or eliminate) the need to compromise in any of the four P's in the future."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "NF9XC7",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/Pic_of_Alec.jpg",
    "name": "Alec Bills",
    "code": "S8NQ3V",
    "biography": "Alec is a PhD Student at Carnegie Mellon University. He is interested in batteries and electric transportation, particularly in electric and hybrid electric aircraft."
   }
  ],
  "description": "Modeling electric vehicle systems and their batteries helps to hasten the adoption and development of electric vehicles by clarifying their capabilities and requirements. Much progress has been made in electrifying automobiles, but less has been made in aircraft, which contribute a significant fraction of the greenhouse gas emissions from transportation.  Aircraft have different battery requirements than automobiles and other modes of ground transportation.  Specifically, the take-off and climb stages of flight can require discharge rates far greater than ground based systems.To study the effects of electrifying aviation, models of aircraft and batteries need to be integrated and studied together.  It is essential to calculate the parameters of both the aircraft and the battery because these two systems are dependent on each other.We  use  Julia  to  model  both  aircraft  and  batteries.   To  model  aircraft,  a  physics  based  performance model is used to calculate the energy and power requirements of the system.  We use historical aircraft of various size and configurations to calculate energy and power requirements of different classes of aircraft. Our lab has modeled both eVTOL and conventional aircraft. Convert-ing the model from MATLAB to Julia yielded a massive speedup, enabling us to test many more configurations and classes of aircraft.We use several battery models depending on the size and battery requirements of the mode of transportation.  For modes of that are capable of being powered by Lithium-Ion batteries, we use psuedo-2D single particle models incorporating all relevant properties of batteries, including energy, discharge rates, mass, and temperature. These models involve large systems of differential equations which can be efficiently solved using the DifferentialEquations.jl package. Porting these battery models to Julia yielded massive speedups, enabling parameter sweeps and use-case specific optimization  of  battery  cell  parameters.   Larger  and  longer  range  forms  of  transportation  have battery requirements that exceed what can be provided by Lithium-Ion batteries.   For example,a fully electric commercial aircraft could require a Lithium Air battery.  We also use the speed provided by Julia to increase our modeling capabilities for these forms of transportation.  In thistalk, we will show an integrated model of a Lithium Air battery and an aircraft performance model.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T17:25:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-25T17:35:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Electrifying Transportation with Julia",
  "abstract": "In this talk, we will discuss implementation of various models relevant for electrochemical energy systems in order to more rapidly optimize component design and use-case specific optimization.We will show massive performance improvements gained through Julia for a variety of popularpseudo-2D  porous  electrode  models  describing  Li-ion  batteries.   In  addition,  we  will  illustrate an example of an integrated design workflow of an aircraft power dynamics model along with a battery model, implemented within Julia."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "JVUMQJ",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Joshua Ballanco",
    "code": "TV9TVY",
    "biography": null
   }
  ],
  "description": "In the universe of programming languages, success for any new language hangs on\r\nits ability to simplify some class of problem that exceed the capabilities of\r\nother existing languages to generate simple solutions for. The concept of a\r\nstate machine is a powerful tool that programmers have used for ages to address\r\nall manner of challenges, but until now implementing a state machine has\r\ntypically required either the use of involved external libraries or the design\r\nof relatively opaque algorithms and data structures. Julia changes all of that\r\nby embracing multiple dispatch and an extensible type system that, together,\r\nprovide everything a programmer requires to design and develop even the most\r\ncomplex of state machines.\r\n\r\nThis presentation will begin with a basic introduction to the concepts behind\r\nstate machines and their implementation and then dive into an example of how\r\none might use the concept of a state machine to handle the parsing of a regular\r\nexpression into a Julia data structure. Continuing from there, we will look at\r\nhow matching a regular expression to a string can, itself, be implemented using\r\na state machine. All the while, we will only require Julia, its type system,\r\nand a handful of multiply dispatched methods.\r\n\r\nFinally, we will review various ways in which state machines implemented in\r\nJulia can be extended and iterated upon without requiring any new libraries or\r\ntools beyond those used in their initial implementation. We will also consider\r\nhow even more complex tasks, including even an entire HTTP request/response\r\nhandler, can be tackled using the exact same approach. By the end, it should be\r\nclear that the killer feature that Julia brings to the world of programming\r\nlanguages is the ability to develop state machines in a way that is clear,\r\nconcise, performant, and infinitely flexible.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T11:30:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-25T11:40:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Julia's Killer App(s): Implementing State Machines Simply using Multiple Dispatch",
  "abstract": "Julia's embrace of multiple dispatch as a key organizing concept provides\r\ndevelopers with all the tools they need to simply implement state machine based\r\nsolutions to a wide range of problems. This presentation will explore a series\r\nof increasingly complex tasks that can all be addressed using a clever\r\ncombination of types and multiple dispatch."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "ZFQHDS",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/jeff_bezanson.jpeg",
    "name": "Jeff Bezanson",
    "code": "JWDSCE",
    "biography": "Jeff is one of the creators of Julia, co-founding the project at MIT in 2009 and eventually receiving a Ph.D. related to the language in 2015. He continues to work on the compiler and system internals, while also working to expand Julia’s commercial reach as a co-founder of Julia Computing, Inc."
   }
  ],
  "description": "As everyone knows, the problem with Julia is that it uses 1-based indexing! Well, of course that's not it, but are there any *real* problems? While there are any number of readily apparent issues involving performance,\r\nmissing functionality, and so on, those are being fixed every day. Subtler issues lurk beneath the surface. In this talk I will present some of the tricker, more hidden, and more fundamental problems involving the type system, object model, and core language generally --- things that keep me up at night. For example, did you know that Julia's types are not closed under intersection, but that it would be nice if they were? The good news is that these are all things I believe we can solve --- in time --- to make Julia a meaningfully better language.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T09:30:00-04:00",
   "room": {
    "en": "NS Room 130"
   },
   "end": "2019-07-25T10:00:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "What's Bad About Julia",
  "abstract": "I'll describe some of the more fundamental issues in Julia today, as I see it, and how we can potentially solve them to get a better language."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "L983HR",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/4346399.jpeg",
    "name": "Amgad Naiem",
    "code": "9T9XUK",
    "biography": "I'm a Phd Student at Cairo University and chief technical lead at [Optomatica](https://www.optomatica.com) \r\n\r\nI have been working with Julia since 2013 and have developed many applications on it throughout these years. I also have some contributions on Julia Ecosytem."
   },
   {
    "avatar": null,
    "name": "Mohammed El-Beltagy",
    "code": "BR3F8Y",
    "biography": null
   }
  ],
  "description": "##Julia web servers deployment\r\nTo deploy Julia web servers easily, we developed an open-source buildpack which is available on https://github.com/Optomatica/heroku-buildpack-julia.\r\nIt just requires `Project.toml` and `Manifest.toml` in the root of the repository to be pushed and it automatically download dependencies and make the server available on [Heroku](https://heroku.com).\r\nIt also precompiles all dependencies for speedy server boot time. \r\n\r\nWe will present our experience in making this buildpack and how we optimized it so that the web server boot time is minimized. We compare its performance with having a docker instance and it outperforms having a docker image and it requires less maintenance overhead than having a docker image. This can help many Julia users deploying web servers in no time.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T11:30:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-25T11:40:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Julia web servers deployment",
  "abstract": "We present our experience in deploying Julia web servers in production systems. We developed a custom buildpack that facilitates deploying web servers on Heroku. It is built so that any application requires almost no special code to be deployed."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "UEDNGH",
  "track": null,
  "state": "confirmed",
  "duration": 210,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/154641-1.jpeg",
    "name": "Matt Bauman",
    "code": "VUPRBT",
    "biography": "Matt Bauman is a Senior Research Scientist at [Julia Computing](https://www.juliacomputing.com), focusing on teaching and training as well as continuing to improve Julia's array infrastructure. He’s been contributing to both the core language and multiple packages since 2014. At his previous position as a Data Science Fellow at the University of Chicago’s Center for Data Science and Public Policy, he longed for dot-broadcasting in Python. He recently defended his PhD in Bioengineering from the University of Pittsburgh, focusing on neural prosthetics."
   }
  ],
  "description": "Interest and excitement in machine learning (ML) has skyrocketed in recent years due to its proven successes in many disparate domains.  Julia is uniquely positioned as a strong language for ML due to its high performance, ease of use, and groundbreaking research in differentiable programming.\r\n\r\nIn this interactive workshop you will learn the core concepts that drive and underpin modern machine learning techniques.  The first half incrementally introduces key ML terminology and concepts as you build and train your first neural network with Flux. Covered along the way are data representations, models, gradient descent, training, and testing.  Then take a step back and explore the wide array of applications of machine learning with a handful of demonstrations of different tasks and models.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-22T08:30:00-04:00",
   "room": {
    "en": "PH 203N"
   },
   "end": "2019-07-22T12:00:00-04:00"
  },
  "submission_type": {
   "en": "Workshop (half day)"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Machine Learning Workshop",
  "abstract": "Demystify machine learning buzzwords by learning how to train and use your own neural network in this interactive workshop.  We'll cover the foundational principles that underpin modern machine learning and demonstrate how Julia makes it easy and fast."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "KJ9SGA",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Dhairya Gandhi",
    "code": "83D8SQ",
    "biography": "Dhairya Gandhi received his Bachelors in Electrical and Electronics Engineering from Birla Institute of Technology and Science, Pilani (2018) and is currently a Data Scientist at Julia Computing. He is a regular contributor to the machine learning stack in Julia."
   }
  ],
  "description": "ML has provided us with the tools to think of data as a source of insight. It isn’t a stretch to apply the same thinking towards some of the most pressing socio economic calamities we as a society are faced with.\r\n\r\nMask RCNN is a state of the art object detection and segmentation net that was developed by FAIR and has shown tremendous leaps in terms of segmentation while being conceptually simple. We present an all-Julia Flux implementation of Mask RCNN and our methodology of setting up the segmentation task. We use satellite images of cities and try to identify regions where slums exist.\r\n\r\nFinally we share our results of our findings.\r\n\r\nCode:\r\nThe code is currently private before it is released openly through contributions to various existing projects like the Flux model-zoo and Metalhead.jl.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T17:25:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-24T17:35:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Machine Learning for Social Good",
  "abstract": "Using Julia and Flux.jl, we want to show how we have applied modern neural architectures like Mask RCNN and Inception to identify diseases and slums in metropolitan cities."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "PSAX8D",
  "track": null,
  "state": "confirmed",
  "duration": 60,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/Shen_profile_pic.jpg",
    "name": "Kelly Shen",
    "code": "W9HTMA",
    "biography": "Kelly Shen is a data engineer at Etsy, where she works on improving the e-commerce company’s in-house A/B testing platform. She has been using Julia since her undergraduate days at MIT. In her free time, Kelly enjoys reading, painting and listening to music."
   },
   {
    "avatar": null,
    "name": "Nathan Daly",
    "code": "JP9VJF",
    "biography": "Nathan Daly is a Software Engineer at [RelationalAI](http://relational.ai). He was first introduced to the idea of contributing to JuliaLang as one small way to help fight climate change by making scientific computing a little bit easier: http://worrydream.com/ClimateChange"
   }
  ],
  "description": "JuliaCon 2018 was the most diverse JuliaCon yet. Though the success of this event demonstrated progress in the diversity and inclusivity of our community, the continued underrepresentation of individuals identifying as female or as racial/ethnic minorities, for example, indicates that we have a long way to go. As greater language stability increases the confidence of our community members to recruit new users and to invest further in the language and its community, interest in diversity efforts tied to the language seem to be gaining momentum. We would like to hold a birds of a feather session to discuss and brainstorm diversity and inclusion in the Julia community.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T14:30:00-04:00",
   "room": {
    "en": "BoF: Room 353"
   },
   "end": "2019-07-24T15:30:00-04:00"
  },
  "submission_type": {
   "en": "Birds of Feather"
  },
  "resources": [],
  "do_not_record": true,
  "title": "Diversity and Inclusion in Julia Community",
  "abstract": "We’ll have a birds of a feather session to discuss and brainstorm diversity and inclusion in the Julia community. All are welcome!"
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "MHUAX7",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/zwitch-headshot.png",
    "name": "Randy Zwitch",
    "code": "XACTRF",
    "biography": "Randy Zwitch is Senior Director of Developer Advocacy at OmniSci and a long-time Julia user (somewhere between 0.2 and 0.3 of julia). Randy is a committed open-source developer and maintainer, contributing to packages in the Julia, Python and R communities, mostly around data visualization, data engineering and database technologies."
   }
  ],
  "description": "For this talk, I will highlight the work-to-date in bringing the functionality of OmniSci to Julia, and how all of the work of others on packages for geospatial, decimal support, Thrift and Apache Arrow make OmniSci.jl  possible. Specifically, I will discuss:\r\n\r\n* Why OmniSci and Julia are a great fit (performance, LLVM)\r\n* Connecting to OmniSci from Julia\r\n* Performing basic queries in millisecond speed\r\n* Future work towards end-to-end analytics on the GPU in Julia",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T15:00:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-24T15:30:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "OmniSci.jl: Bringing the open-source, GPU-accelerated relational database to Julia",
  "abstract": "OmniSci (formerly MapD) is an open-source relational database built from the ground-up to run on GPUs, providing millisecond query speed on multi-billion row datasets. This talk presents OmniSci.jl, the database client for OmniSci written completely in Julia and a basic demonstration of using OmniSci and Julia together, with the aim of encouraging community collaboration on GPU accelerated analytics."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "J779CB",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/IMG-7432.jpg",
    "name": "Scott Haney",
    "code": "MBHYMM",
    "biography": "I Received a doctorate degree in electrical and computer engineering from Drexel University in 2011. I started out doing scientific programming in R while working on my doctoral thesis and recently found out about and got excited about the Julia programming language. My main interest areas in programming are software architecture and numerical analysis."
   }
  ],
  "description": "Have you ever updated an algorithm's code just to find that the algorithm has changed in unexpected ways? Have you ever started coding an algorithm just to think to yourself that you had already done something extremely similar for a different algorithm? These problems are often the case because code is not broken down into clear conceptual components that are independent from one another and easy to reuse.\r\n\r\nTo illustrate how this can be accomplished we will walk through the implementation of three highly similar iterative eigenvalue/eigenvector algorithms. It will be shown that each of the three iterative algorithms consists of the same main conceptual components which will be extracted into a single method used by all three iterative algorithms.\r\n\r\nThe result will be code that is easy to follow at a high level because breaking it into high level conceptual components will make it easier to read and follow. Changes will also be easier to make because finding the correct area of the code to change will be easier and there will be less risk of unexpected side effects because the other components should be independent. Finally some discussion will be made about the performance implications of introducing more abstractions and how if the abstractions are kept at the higher levels of the algorithms code it is highly unlikely that performance will be significantly impacted.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T14:30:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-25T15:00:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "Writing maintainable Julia code",
  "abstract": "How to use abstractions to write code that will be easy to follow and change while also not significantly impacting performance"
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "J39LVP",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": null,
    "name": "Yingbo Ma",
    "code": "E8HK8A",
    "biography": "Yingbo Ma was a math major in the University of California, Irvine, and he is currently taking a gap year. He is a scientific computing intern in predictive healthcare analytics at Julia Computing, Inc. and the Center for Translational Medicine at the University of Maryland Baltimore. He is very interested in numerical treatments for differential equations and implemented a number of integrators and interfaces in the JuliaDiffEq organization. His future goal is to develop new efficient algorithms for solving differential equations and to apply them in real practice."
   }
  ],
  "description": "The solution of the stiff ordinary differential equation (ODE) systems resulting from QsP models is a rate-limiting step in large-scale population studies. Here we review the ongoing efficiency developments within the JuliaDiffEq numerical differential equation solver ecosystem with a focus on ODEs derived from QsP models. These models have specific features that can be specialized in order to gain additional efficiency in the integration, such as their small size (normally <500 ODEs), frequent dosing events, and multi-rate behaviors. We demonstrate how new implementations of high order Rosenbrock methods with PI-adaptive time stepping, exponential propagation iterative methods (EPRIK) with adaptive Krylov expmv calculations, and implicit-explicit singly diagonally implicit Runge-Kutta methods (IMEX SDIRK) can be advantageous over classical schemes like LSODA and Sundials CVODE on these types of models and discuss the future directions.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T15:45:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-25T16:15:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "Efficient Stiff Ordinary Differential Equation Solvers for Quantitative Systems Pharmacology (QsP)",
  "abstract": "QsP is a sophisticated and effective way to predict the interaction between drugs and the human body, however, simulating QsP models can take a long time because of the intrinsic stiffness in transient chemical reactions. Here we take a deep look at the efficiency of various stiff ordinary differential equation solvers in the JuliaDiffEq ecosystem applied to QsP models, and utilize benchmarks to summarize how the ecosystem is progressing and what kinds of advances we can expect in the near future."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "KGHF7T",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": null,
    "name": "Elisabeth Roesch",
    "code": "A9GFJJ",
    "biography": "Elisabeth Rösch did her undergraduate studies in Munich, Germany, (B.Sc. Bioinformatics - Technical University Munich and Ludwig-Maximilans-Univerisity Munich) and postgraduate studies in London, UK, (M.Sc. Bioinformatics and Theoretical Systems Biology- Imperial College London). Currently she is doing her PhD in the Maths and Stats department of the University of Melbourne, Australia. She focuses her research on the combination of machine learning and mechanistic modelling applied to Theoretical Systems Biology."
   }
  ],
  "description": "A [neural Ordinary Differential Equation](https://arxiv.org/abs/1806.07366) (ODE) is a differential equation whose evolution equation is a neural network. We can use neural ODEs to model nonlinear transformations by directly learning the governing equations from time course data. Therefore, neural ODEs present a novel method for modelling time series in an elegant manner as they allow us to use sophisticated differential equations solving procedures in the field of machine learning, an area of already high and still increasing demand.\r\n\r\nIn this talk we discuss [DiffEqFlux.jl](https://arxiv.org/abs/1902.02376), a package for designing and training neural ODEs. We demonstrate how to fit neural ODEs against data by using the L2 loss function, and explain how Julia's automatic differentiation is used to calculate the gradients through the differential equation solvers to compute the gradients of the loss function. While this is the \"standard\" method, it involves solving an ODE at each step of the optimization which can be very time consuming. Thus, we introduce new methodologies available in DiffEqFlux.jl, to improve the efficiency and robustness of the fitting. First, we demonstrate new functionalities provided by a bridge to the [two stage collocation method](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2631937/\r\n) of the package [DiffEqParamEstim.jl](https://docs.juliadiffeq.org/latest/analysis/parameter_estimation.html). Second, we show how to effectively use these functions in a mixed training loop to improve the speed and robustness of the fitting. Third, we demonstrate and explain a new loss function in DiffEqFlux.jl which allows for multiple shooting, and show its performance characteristics. Together, these three features improve the performance and robustness of the fitting process of neural ODEs in Julia and, thus, allow it to scale to more practical models and data.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T16:35:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-24T17:05:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "Fitting Neural Ordinary Differential Equations with DiffeqFlux.jl",
  "abstract": "Neural Ordinary Differential Equations (neural ODEs) are a brand new and exciting method to model nonlinear transformations as they combine the two fields of machine learning and differential equations. In this talk we discuss DiffEqFlux.jl, a package for designing and training neural ODEs, and we introduce new methodologies to improve the efficiency and robustness of neural ODEs fitting."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "8DTHDK",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": null,
    "name": "Dheepak Krishnamurthy",
    "code": "ZWPRXJ",
    "biography": "I am an energy researcher and analyst at the National Renewable Energy Laboratory. My interests are power system operation, optimization, high-performance computing, and programming language theory."
   }
  ],
  "description": "Production Cost Modeling (PCM) of power systems captures all the costs of operating a fleet of generators. This model captures hourly chronological security constrained unit commitment and economic dispatch simulation while minimizing costs and adhering to a wide variety of operating constraints. In this talk, we will cover the basics of Production Cost Modeling, and will explain how we have implemented this in Julia using JuMP. We will also discuss our experiences using Julia and JuMP and express the benefits to our users and some challenges we faced.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T16:15:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-23T16:45:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "Open Source Power System Production Cost Modeling in Julia",
  "abstract": "Operating a power system on a day to day basis involves optimizing the operation of the given energy system. Modeling these operations requires solving a Mixed Integer Linear Programming problem. In this talk, we will present methods for solving a production cost model in Julia and JuMP using PowerSimulations.jl"
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "H7TZTT",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/david_widmann1.jpg",
    "name": "David Widmann",
    "code": "BKDQGH",
    "biography": "I'm a PhD student at the IT department and the Center for Interdisciplinary Mathematics (CIM) at Uppsala University, Sweden. For my master thesis at TU Munich, Germany, I studied a delay differential equation model from biology and, since Julia is my preferred scientific programming language, I started to contribute to the development of [DelayDiffEq.jl](https://github.com/JuliaDiffEq/DelayDiffEq.jl). My research interests are uncertainty quantification in machine learning and differential equations."
   }
  ],
  "description": "Time delays are an inherent part of many dynamical systems in different scientific areas such as biology, physiology, chemistry, and control theory, suggesting to model these systems with delay differential equations (DDEs), i.e., differential equations including time delays. However, solving DDEs numerically in an efficient way is hard. In my talk I present [DelayDiffEq.jl](https://github.com/JuliaDiffEq/DelayDiffEq.jl), a Julia package for solving DDEs. I show how it integrates into the DifferentialEquations ecosystem and makes use of the large number of numerical algorithms in [OrdinaryDiffEq.jl](https://github.com/JuliaDiffEq/OrdinaryDiffEq.jl) for solving ordinary differential equations.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T15:45:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-23T16:15:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "Solving Delay Differential Equations with Julia",
  "abstract": "Delay differential equations (DDEs) are used to model dynamics with inherent time delays in different scientific areas; however, solving them numerically in an efficient way is hard. This talk demonstrates how the DifferentialEquations ecosystem allows to solve even complicated DDEs with a variety of different numerical algorithms."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "9BRTVV",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Shubham Maddhashiya",
    "code": "YMXSBB",
    "biography": "Shubham Maddhashiya is a third-year undergraduate student majoring in Ocean Engineering and Naval Architecture at the Indian Institute of Technology, Kharagpur, India. Shubham is interested in scientific computing and artificial intelligence in robotics."
   }
  ],
  "description": "In this talk, I will introduce IVIVC.jl, a state of the art package for pharmaceutical modelling and simulation-based in Julia. In the core, IVIVC.jl uses Optim.jl as optimization library to model the in-vitro data and then correlates the model with deconvoluted in vivo data. This package establishes three levels (A, B and C) of in vitro-in vivo correlation (IVIVC). IVIVC is the relationship between parameter derived from a pharmacokinetic property produced by a dosage form and a physicochemical property of the same dosage form. The pharmacokinetic properties include maximum plasma concentration (Cmax) or area under the plasma concentration-time curve (AUC). When an IVIVC correlation is established, it is used for development and optimization of drug formulations.\r\nUsing IVIVC.jl, one can accelerate drug development and can introduce a drug in the market faster. IVIVC can be used to substitute human bioequivalence studies in the initial approval process, the scale-up process, and the post-approval changes. This project is under the University of Maryland, Baltimore and the authors are me, Jogarao Gobburu and Vijay Ivaturi.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T16:55:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-25T17:05:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "IVIVC.jl: In vitro – in vivo correlation module as part of an integrated pharmaceutical modeling and simulation platform",
  "abstract": "IVIVC.jl is a state of the art package for predictive mathematical modelling which correlates in vitro property (rate of drug dissolution) and in vivo response (plasma drug concentration profile). An IVIVC is meant to serve as a surrogate for in vivo bioavailability. This relationship can guide product development and support biowaivers. IVIVC.jl pipelines input bio-data to an IVIVC model with validations and it involves mathematical modelling, optimization and data visualisation accelerated with Julia."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "7SDCJU",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": null,
    "name": "Shashi Gowda",
    "code": "FRZ9B3",
    "biography": "I'm a first year grad student at MIT. Formerly programmer at Julia Computing."
   }
  ],
  "description": "This talk is an overview of the JuliaGizmos ecosystem. It starts with the basics of creating a simple page, showing it in various forms, to Interact.jl and beyond. I will present work done by many people that have been aggregated in this github niche, mainly that of Mike Innes, Pietro Vertechi, Joel Mason, Travis DePrato, Sebastian Pfitzner and myself.\r\n••••••••••••••\r\nOutline of the talk:\r\n\r\n1. Showing any Julia object, serving it on a web server\r\n2. Executing and talking to JavaScript: the `@js` syntax\r\n3. Interact.jl -- past and future\r\n4. Syntax: Building your own JavaScript based library with seamless Julia bindings\r\n5. Deploying a native-looking app as a Julia script\r\n6. A brief update on (other people's) work on transpiling Julia to JS.\r\n\r\nA common question we get asked on Slack is -- \"is there a replacement for R's shiny in Julia?\". The answer is YES, and you can help us build it out!",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T11:00:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-25T11:30:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "Julia + JavaScript = <3",
  "abstract": "Julia and JavaScript come together like peanut butter and chocolate\r\nThis talk is an overview of the JuliaGizmos ecosystem. It starts with the basics of creating a simple page, showing it in various forms, to Interact.jl and beyond. I will present work done by many people that have been aggregated in this github niche, mainly that of Mike Innes, Pietro Vertechi, Joel Mason, Travis DePrato, Sebastian Pfitzner and myself."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "BCYWZJ",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": null,
    "name": "Stefan Karpinski",
    "code": "9NNRE7",
    "biography": "Stefan is one of the co-creators of Julia and a co-founder of Julia Computing. Before Julia, he was a software engineer and data scientist at [Akamai](https://www.akamai.com), [Citrix Online](https://www.gotomeeting.com), and [Etsy](https://etsy.com). In addition to running Julia Computing, he holds a part-time appointment as a Research Engineer at New York University as part of the Moore-Sloan Data Science Environment."
   }
  ],
  "description": "The former kind of sharing of types stems from the external nature of multiple dispatch: the source of many problems in class-based OOP is that methods have to live \"inside of\" classes. Simply by associating methods with generic functions rather than the type that they operate on, multiple dispatch avoids many of the problems that OOP has.\r\n\r\nThe latter kind of sharing stems from the ability to correctly choose specialized code based on the types of all arguments of a function. There are patterns like double dispatch to try to deal with this in single dispatch languages, but they are cumbersome, brittle and opt-in, meaning that unless someone else planned for you to extend their code, you are unlikely to be able to do so.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T11:00:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-25T11:30:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "The Unreasonable Effectiveness of Multiple Dispatch",
  "abstract": "If you're familiar with Julia and its ecosystem, you may have noticed something lovely but a bit puzzling: there seems to be an unusually large amount of code reuse between packages compared to other seemingly similar languages. This sharing of code comes in two forms:\r\n\r\n1. Sharing basic types among a wide variety of packages providing disparate functionality;\r\n2. Sharing generic algorithms that work on various implementations of common abstractions.\r\n\r\nWhy does generic code in Julia \"just work\"? Why do Julia packages seem to share types with so little friction? Both kinds of reuse are supposed to be natural benefits of class-based object-oriented languages. After all, inheritance and encapsulation are two of the four pillars of OOP. Even more puzzling is that Julia has no encapsulation and doesn't allow inheriting from concrete types at all. Yet both kinds of code reuse are rampant. What is going on? In this talk, I make the case that both of kinds sharing stem directly from Julia's multiple dispatch programming paradigm."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "3YBZLC",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "James Bradbury",
    "code": "NKXXRC",
    "biography": "James Bradbury is a research software engineer on the Google Brain team, where he works on software and languages for machine learning."
   }
  ],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T16:45:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-23T16:55:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Targeting Accelerators with MLIR.jl",
  "abstract": "MLIR is a flexible compiler infrastructure with an open ecosystem of dialects, built for a world of increasingly heterogeneous hardware. With its support for metaprogramming and extensible JIT compiler, Julia is well-positioned as a frontend language for the MLIR stack."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "QJAUAT",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": null,
    "name": "Chris Rackauckas",
    "code": "WUWQQ3",
    "biography": "Chris' research and software combines AI with differential equation models of human organs to give patients accurate and personalized drug doses: reducing pain and complications for patients while reducing treatment costs for hospitals.\r\n\r\nChris Rackauckas is an applied mathematics instructor at the Massachusetts Institute of Technology and a senior research analyst at the University of Maryland, School of Pharmacy in the Center for Translational Medicine. Chris's recent work is focused on bringing personalized medicine to standard medical practice through the proliferation of mathematical software. His work on developing the DifferentialEquations.jl solver suite along with over a hundred other Julia packages, not only earned him the inaugural Julia Community Prize and front page features in tech community sites, it is also the foundation of the PuMaS.jl package for Pharmaceutical Modeling and Simulation, set to release in March 2019. Chris’ work with PuMaS makes it possible to predict the optimal medication dosage for individuals, reducing the costs and potential complications associated with treatments. The software is currently being tested in the administration of treatment for neonatal abstinence syndrome (NAS), an opioid withdrawal disorder in newborn babies. NAS requires medically administered morphine doses every four hours to prevent the infants from experiencing withdrawal symptoms. PuMaS is being used to predict personalized safe dosage regimens by incorporating realistic biological models (quantitative systems pharmacology) and deep learning into the traditional nonlinear mixed effects (NLME) modeling framework.  This software and its methodology are also being tested in clinical trials at Johns Hopkins University for its ability to predict an individual's drug response to vancomycin and automatically prescribe optimal doses directly from a patient's health records.\r\n\r\nChris started this work while completing his Masters and Ph.D. at the University of California, Irvine where he was awarded the Mathematical and Computational Biology institutional fellowship, the Graduate Dean's Fellowship, the National Science Foundation's Graduate Research Fellowship, the Ford Predoctural Fellowship, the NIH T32 Predoctural Training Grant, and the Data Science Initiative Summer Fellowship. His research with his advisor, Dr. Qing Nie, focused on the methods for simulating stochastic biological models and detailing how the randomness inherent in biological organisms can be controlled using stochastic analysis. Chris bridged the gap between theory and practice by having a \"wet lab bench\" in Dr. Thomas Schilling’s lab, where these methodologies were tested on zebrafish. Fluorescence Light Microscopy (FLIM) measurements of retinoic acid in the zebrafish hindbrain showed that the predicted control proteins could attenuate inherent biological randomness. The result was a verified mathematical theory for controlling the randomness in biological signaling. Chris received the Kovalevsky Outstanding Ph.D. Thesis Award from the Department of Mathematics upon graduation and was showcased in an interview \"Interdisciplinary Case Study: How Mathematicians and Biologists Found Order in Cellular Noise\" in iScience.\r\n\r\nAs an undergraduate at Oberlin College, Chris was awarded the NSF S-STEM scholarship and the Margaret C. Etter Student Lecturer Award by the American Crystallographic Association, an award usually given for PhD dissertations, for his work on 3+1 dimensional incommensurate crystal structure identification of H-acid. This award was given for Service Crystallography for its potential impact on industrial dye manufacturing."
   }
  ],
  "description": "Dynamical models are often interesting due to the high-level qualitative behavior that they display. Differential equation descriptions of fluids accurately predict when drone flight will go unstable, and stochastic evolution models demonstrate the behavior for how patterns may suddenly emerge from biological chemical reactions. However, utilizing these models in practice requires the ability to understand, prediction, and control these outcomes. Traditional nonlinear control methods directly tie the complexity of the simulation to the control optimization process, making it difficult to apply these methods in real-time to highly detailed but computationally expensive models. \r\nIn this talk we will show how to decouple the computation time of a model from the ability to predict and control its qualitative behavior through a mixture of differential equation and machine learning techniques. These new methods directly utilize the language-wide differentiable programming provided by Flux.jl to perform automatic differentiation on differential equation models described using DifferentialEquations.jl. We demonstrate an adaptive data generation technique and show that common classification methods from machine learning literature converge to >99% accuracy for determining qualitative model outcomes directly from the parameters of the dynamical model. Using a modification of methods from Generative Adversarial Networks (GANs), we demonstrate an inversion technique with the ability to predict dynamical parameters that meet user-chosen objectives. This method is demonstrated to be able to determine parameters which constrains predator-prey models to a specific chosen domain and predict chemical reaction rates that result in Turing patterns for reaction-diffusion partial differential equations. Code examples will be shown and explained to directly show Julia users how to do these new techniques. Together, these methods are scalable and real-time computational tools for predicting and controlling the relation between dynamical systems and their qualitative outcomes with many possible applications.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T16:45:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-23T17:15:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "Scientific AI: Domain Models with Integrated Machine Learning",
  "abstract": "Modeling practice seems to be partitioned into scientific models defined by mechanistic differential equations and machine learning models defined by parameterizations of neural networks. While the ability for interpretable mechanistic models to extrapolate from little information is seemingly at odds with the big data \"model-free\" approach of neural networks, the next step in scientific progress is to utilize these methodologies together in order to emphasize their strengths while mitigating weaknesses. In this talk we will describe four separate ways that we are merging differential equations and deep learning through the power of the DifferentialEquations.jl and Flux.jl libraries. Data-driven hypothesis generation of model structure, automated real-time control of dynamical systems, accelerated of PDE solving, and memory-efficient deep learning workflows will all shown to be derived from this common computational structure of differential equations mixed with neural networks. The audience will leave with a new appreciation of how these two disciplines can benefit from one another, and how neural networks can be used for more than just data analysis."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "GRZZBA",
  "track": null,
  "state": "confirmed",
  "duration": 120,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/headshot-300px.png",
    "name": "Kevin S Bonham",
    "code": "ZT3A3L",
    "biography": "Kevin received a BS in Biochemistry and Cell Biology from the University of California, San Diego, and a PhD in Immunology from Harvard University. He is currently a Research Scientist at Wellesley College, a women's college in Eastern Massachusetts, where he studies the relationship between the gut microbiome and childhood cognitive development, and is the author of the `Microbiome.jl` and `GenderInference.jl` packages. He was awarded a grant from the Sloan Foundation through Julia Computing to develop course materials for Biology majors at Wellesley to learn to program in julia."
   },
   {
    "avatar": null,
    "name": "Elwin van 't Wout",
    "code": "MJLKGA",
    "biography": null
   },
   {
    "avatar": null,
    "name": "Anna Harris",
    "code": "FAQYNX",
    "biography": null
   }
  ],
  "description": "Diversity of users is fundamental for the development of an open language such as Julia. Because it is a young, but very promising programming language, the promotion of working groups that foster the spread of its usage among users from different regions, backgrounds, ages, and social contexts can shed light on bugs and potential growth because of the different perspectives brought with diversity. The Julia Computing Diversity & Inclusion Award funded five projects aimed at promoting the usage of Julia Language with different approaches, in different regions of the planet. In this session, we will share our experience in our projects, talking about how we planned, executed and evaluated the outcomes, and what we learned.\r\n\r\nFor more information about individual projects funded, [see here](https://juliacomputing.com/blog/2018/11/30/DandI-grant-awards.html).",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T15:45:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-24T17:45:00-04:00"
  },
  "submission_type": {
   "en": "Minisymposia / Extended Presentation"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Raising Diversity & Inclusion among Julia users",
  "abstract": "This session aims at discussing/showcasing our experience promoting diversity and inclusion in the US, Brazil, Chile and online, with the help of the Julia Computing Diversity & Inclusion Award, funded by the Sloan Foundation."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "BD9EBF",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Cédric St-Jean-Leblanc",
    "code": "V38AC3",
    "biography": "AI researcher focused on decision making under uncertainty, and data scientist."
   }
  ],
  "description": "At R2 Inc., we monitor in real-time tens of thousands of sensors in industrial plants, looking for anomalous behaviour. Industrial processes are usually very well understood and predictable, making them ideal candidates for classical Bayesian analysis. Off-the-shelf modelling approaches like Stan offer great flexibility in formulating a model, but the Markov Chain Monte Carlo algorithms they use are slow on large datasets, which hinders model iteration. Kalman filters can provide much faster, exact posterior probabilities, by assuming that the uncertainties are Gaussian and that the hidden state evolution is linear.\r\n\r\nWe have built a probabilistic programming language around the switching Kalman filter algorithm. It was implemented as a Julia macro, and supports Unitful time series with missing data. I will present its design, implementation and some of its applications.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T17:25:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-25T17:35:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "A probabilistic programming language for switching Kalman filters",
  "abstract": "I will present a probabilistic programming language that implements switching Kalman filters, and its applications to industrial time series processing."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "EKN9AD",
  "track": null,
  "state": "confirmed",
  "duration": 60,
  "speakers": [
   {
    "avatar": null,
    "name": "Clark Evans",
    "code": "AUYGJR",
    "biography": null
   }
  ],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T11:00:00-04:00",
   "room": {
    "en": "BoF: Room 353"
   },
   "end": "2019-07-24T12:00:00-04:00"
  },
  "submission_type": {
   "en": "Birds of Feather"
  },
  "resources": [],
  "do_not_record": true,
  "title": "Sustainable Development and Open Source Monetization",
  "abstract": "As the Julia community grows and becomes core tooling to many scientists and businesses, sustainably keeping members of the community as developers of free software developers is vital to the health of the ecosystem. In this discussion we will talk about the various ways we ourselves are funding or have been funded for Julia-based open source software development, and hypothesize alternative methods such as crowdfunding."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "HBBG8N",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/Farid.JPG",
    "name": "Dewan Md. Farid",
    "code": "CXNMML",
    "biography": "Dr. Dewan Md. Farid is an Associate Professor, Department of Computer Science and Engineering, United International University, Bangladesh. He worked as a Postdoctoral Fellow at the following research groups: (1) Computational Modeling Lab (CoMo), Department of Computer Science, Vrije Universiteit Brussel, Belgium in 2015-2016, and (2) Computational Intelligence Group (CIG), Department of Computer Science and Digital Technology, University of Northumbria at Newcastle, UK in 2013. Dr. Farid was a Visiting Faculty at the Faculty of Engineering, University of Porto, Portugal in June 2016. He holds a PhD in Computer Science and Engineering from Jahangirnagar University, Bangladesh in 2012. Part of his PhD research has been done at ERIC Laboratory, University Lumière Lyon 2, France by Erasmus-Mundus ECW eLink PhD Exchange Program. He has published 73 peer-reviewed scientific articles, including 26 journal papers in the field of machine learning and data mining. Dr. Farid received United Group Research Award 2016 in the field of Science and Engineering. He received following Erasmus Mundus scholarships: (1) LEADERS (Leading mobility between Europe and Asia in Developing Engineering Education and Research) in 2015, (2) cLink (Centre of excellence for Learning, Innovation, Networking and Knowledge) in 2013, and (3) eLink (east west Link for Innovation, Networking and Knowledge exchange) in 2009. Dr. Farid also received Senior Fellowship I, and II award by National Science & Information and Communication Technology (NSICT), Ministry of Science & Information and Communication Technology, Government of Bangladesh respectively in 2008 and 2011. He is a member of IEEE."
   },
   {
    "avatar": "https://pretalx.com/media/avatars/download.jpg",
    "name": "Swakkhar Shatabda",
    "code": "A9KWKS",
    "biography": "Dr. Shatabda is Associate Professor and Undergraduate Program Co-ordinator of Computer Science and Engineering Department.\r\n\r\nHe achieved his Ph. D degree from the Institute for Integrated and Intelligent Systems (IIIS), Griffith University in 2014. His thesis is titled “Local Search Heuristics for Protein Structure Prediction”.  He completed his BSc. in Computer Science and Engineering from Bangladesh University of Engineering and Technology (BUET) in 2007.\r\n\r\nResearch interest of Dr. Shatabda includes bioinformatics, optimization, search and meta-heuristics, data Mining, constraint programming, approximation Algorithms and graph theory. He has a number of quality publications in both national and international conferences and journals.\r\n\r\nHe has worked as Graduate Researcher in Queensland Research Laboratory, NICTA, Australia. Prior entering the teaching line he worked  as a Software Engineer in Vonair Inc, Bangladesh."
   }
  ],
  "description": "In this era of big data, classifying imbalanced real-life data in supervised learning is a challenging research issue. Standard data sampling methods: under-sampling, and over-sampling have several limitations for dealing with big data. Mostly, under-sampling approach removes data points from majority class instances and over-sampling approach engenders artificial minority class instances to make the data balanced. However, we may lose informative information/ instances using under-sampling approach, and under other conditions over-sampling approach causes overfitting problem. In this talk, we have presented a new cluster-based under-sampling approach by amalgamating ensemble learning (e.g. RandomForest classifier) for classification of imbalanced data that we implemented in Julia. We have collected actual illegal money transaction telecom fraud data, which is highly imbalanced with only 8,213 minority class instances amount 63,62,620 instances. The proposed method bifurcates the data into majority class and minority class instances. Then, clusters the majority class instances into several clusters and considers a set of instances from each cluster to create several sub-balanced datasets. Finally, a number of classifiers are generated using these balances datasets and apply majority voting technique for classifying unknown/ new instances. We have tested the proposed method on separate test dataset that achieved 97% accuracy.",
  "image": "https://pretalx.com/media/juliacon2019/images/HBBG8N/Farid_-_JuliaCon2019.jpg",
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T11:50:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-24T12:00:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Mining Imbalanced Big Data with Julia",
  "abstract": "Machine learning for data Mining applications in imbalanced big data classification is very challenging task. In this talk, we have proposed a new cluster-based under-sampling approach with ensemble learning for mining real-life imbalanced big data in Julia."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "YDVQKM",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Nicolau Leal Werneck",
    "code": "KXTSV7",
    "biography": "Electrical Engineer specialized in Computer Vision and Pattern Recognition"
   }
  ],
  "description": "To attain the best performance with a modern computer, programmers are required to exploit thread and instruction level parallelism and make sure memory access follows suitable patterns. ChipSort.jl is a sorting package that implements techniques exploiting parallelism and memory locality. It uses SIMD instructions to implement  basic operations such as sorting networks, merging networks, and in-place matrix transpose. These operations can be used to sort large arrays using merge-sort exploiting SIMD and cache memory for improved performance. The implementation is largely based on unique Julia features such as generated functions and parametric methods, allowing Julia to generate optimized custom machine code for different architectures based on the same high-level Julia code. Experiments were made with both Intel (AVX2 and AVX512) and AMD (NEON) processors, achieving speedups from 2 up to 17 times in different benchmarks.\r\n\r\nProject documentation: https://nlw0.github.io/ChipSort.jl",
  "image": "https://pretalx.com/media/juliacon2019/images/YDVQKM/logo.png",
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T16:55:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-23T17:05:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "SIMD and cache-aware sorting with ChipSort.jl",
  "abstract": "ChipSort.jl is a sorting package that exploits instruction-level parallelism and cache memory seeking the best performance in any system."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "7BKBZJ",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "David P. Sanders",
    "code": "TJJRTG",
    "biography": "Professor at the National University of Mexico.\r\n\r\nHas been using Julia since early 2014.\r\n\r\nMain co-author of the JuliaIntervals suite of packages.\r\n\r\nHas given Julia tutorials all over the world, some of which are available on YouTube and have over 100,000 views."
   }
  ],
  "description": "We will show how set computations, using interval-based methods, enable us to find the global minimum for difficult nonlinear, non-convex optimization problems of functions $f:\\mathbb{R}^n \\to \\mathbb{R}$, even when the number of local minima is huge, with guaranteed bounds on the optimum value and on the set of minimizers. We can often also find all stationary points in a given box.\r\n\r\nWe will explain the underlying ideas and some details of the Julia implementation in IntervalOptimisation.jl, which relies on spatial branch and bound, as well as showing examples. We can tackle some \"weakly non-convex\" functions ranging up to a few hundred variables, whereas highly oscillatory functions can be very challenging even for $n < 10$.\r\n\r\nFor constrained optimization, we apply **constraint propagation**, as implemented in `IntervalConstraintProgramming.jl`, to eliminate infeasible regions and prove the existence of feasible points. We will show how the above techniques are combined to allow efficient and guaranteed calculations for optimization problems.\r\n\r\nThe `CharibdeOptim.jl` package combines these methods with the heuristic Differential Evolution technique to get an efficient global optimisation tool.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T11:30:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-24T11:40:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Guaranteed constrained and unconstrained global optimisation in Julia",
  "abstract": "Set computations with interval arithmetic allow us to write surprisingly efficient software for guaranteed unconstrained and constrained global optimisation in pure Julia."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "QAAUCS",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Michiel Stock",
    "code": "T3ZCAP",
    "biography": "I am a postdoctoral researcher at the KERMIT (knowledge-based systems) group at Ghent University.\r\n\r\nMachine intelligence and living systems fascinate me. In my research, I develop intelligent techniques to understand, predict and control biological networks. My main toolbox involves a mix of machine learning, optimization, bioinformatics and graph theory. I use these methods to predict how plants, animals, microorganisms and molecules interact with each other. \r\n\r\nMuch of my work involves working together with others, translating biological problems as mathematical or computational ones. Every year, I try to engage students students in projects and theses, doing cool things such as making a beer classifier or designing new proteins. \r\n\r\nDuring my years as a teaching assistant, I was involved in various courses on data analytics and computational intelligence, including statistics, probability theory and machine learning. Now, I am the responsible teacher for the course 'Selected Topics in Mathematical Optimization', learning master students of bioinformatics how solve concrete problems."
   }
  ],
  "description": "I would like to introduce the Kronecker kernel-based framework I developed during my PhD and explain why I would switch from Python to Julia for this.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T11:30:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-23T11:40:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "A general-purpose toolbox for efficient Kronecker-based learning",
  "abstract": "Pairwise learning is a machine learning paradigm where the goal is to predict properties of pairs of objects. Applications include recommender systems, such as used by Amazon, molecular network inference and ecological interaction prediction. Kronecker-based learning systems provide a simple, yet elegant method to learn from such pairs. Using tricks from linear algebra, these models can be trained, tuned and validated on large datasets. The Julia package Kronecker.jl aggregates these tricks, such that it is easy to build such learning systems."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "JAXM9R",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Michel Schanen",
    "code": "DUUAYM",
    "biography": "Michel Schanen is an assistant computational engineer at the mathematics and computer science division (MCS) at the Argonne National Laboratory. He received his PhD in adjoints by automatic differentiation of the message passing interface. At a postdoctoral researcher he worked on large-scale adjoint checkpointing on the supercomputers at Argonne. He now works on large-scale mathematical optimization frameworks with applications in power systems."
   }
  ],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T17:25:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-23T17:35:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Modeling in Julia at Exascale for Power Grids",
  "abstract": "The ExaSGD (Optimizing Stochastic Grid Dynamics at Exascale) application is part of the Department of Energy's Exascale project (ECP). The dawn of renewable energies poses a great challenge to long-term planning with higher uncertainties, not only in the grid load, but also in the energy generation. The goal of this project is to provide policy planners and grid operators with cost effective long term planning solutions that are protected against uncertainties in the grid operation. This talk gives an overview of our implementation and where we leverage Julia's unique capabilities to  make efficient use of the upcoming exascale hardware, while giving engineers a flexible modeling language."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "M8UDFK",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/Mills_Jeff_headshot1.jpg",
    "name": "Jeff Mills",
    "code": "TDLXZB",
    "biography": "Associate Professor\r\nLindner College of Business\r\nUniversity of Cincinnati \r\n\r\nResearch interests: Bayesian inference, statistical hypothesis testing, meta-analyses, Bayesian adaptive randomized controlled trials, time series analysis."
   }
  ],
  "description": "We know that Julia solves the “two-language problem”: it is both fast and efficient (performance), and easy to use (user friendliness).  Using Julia combined with the Bayesian MCMC machinery can solve what we call “the two field problem” in clinical trials, which is that clinical researchers need expertise in more than one field.  \r\n\r\nMedical research - including clinical trials - is frequently conducted by physician researchers who have limited training in inferential statistics and computer programming.  Typically, clinical research teams will have a biostatistician, though this may be an MS level individual who performs pre-specified “off the shelf” analyses, and generally is not someone well-versed in Bayesian inferential tools. The prevalence of “five percentitus,” i.e. looking only for and reporting p-values that are “statistically significant” (p<0.05), testifies to this fact. The advances in computing power and capabilities in the last several decades, along with the subsequent developments in Bayesian computational methods, are only just beginning to have an impact on this.\r\n\r\nAs those conducting and funding clinical RCTs recognize the high costs of these studies (e.g., medication expense, time required, and potential exposure of patients to ineffective treatments), there has been greater enthusiasm for (1) improving statistical analytic methods for RCTs, and 2) using evidence-based methods to examine existing naturalistically-collected clinical data to inform clinical practice without the need for RCTs.  These approaches require far greater statistical and programming knowledge and sophistication from users.  Thus, there is an urgent need to provide statistical tools to clinician-researchers that are intuitive and easy to use, yet sophisticated and powerful enough “under the hood” to answer questions that simpler methods cannot.\r\n\r\nThe “Bayesian machinery” of Markov chain Monte Carlo (MCMC) methods together with Julia offer a solution to this “two-field problem”. They enable exact small sample inference and hypothesis testing for complex models without requiring the restrictive assumptions necessary to obtain analytical tractability (performance), and facilitate the analysis of complex models with basic statistical concepts: frequency distributions, density plots, means, medians, modes, standard deviations, quantiles, and posterior odds (user friendliness).\r\n\r\nThe talk will demonstrate application of this approach using examples from our own research that illustrate our experiences with Bayesian inferential methods for clinical research using Julia.  [the number and detail of examples will be modified to suit the length of the talk].\r\n\r\n•\tReevaluating the evidence from previously conducted RCTs.\r\n•\tAnalysis of abandoned trials.\r\n•\tJoint evaluation of tolerability and efficacy in RCTs.\r\n•\tBayesian hierarchical modeling for meta-analysis evaluating adverse events (“side effects”) in trial participants, \r\n        and examining the difference between industry and federally sponsored randomized controlled trials.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T11:00:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-24T11:30:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "Probabilistic Biostatistics: Adventures with Julia from Code to Clinic",
  "abstract": "Physician scientists conducting clinical trials are typically not statisticians or computer scientists. Perhaps, in a perfect world, they would be, or more realistically could have statisticians and computer scientists on their research team, but that is often not the case. This leads to what we refer to as the “two-field problem.”  Physician-researchers require sophisticated and powerful statistical tools to address complex inferential problems, yet these tools must be intuitive and user-friendly enough not to require advanced statistical knowledge and programming skills.  Using Julia, we illustrate the application of Bayesian probabilistic biostatistics to meta-analyses of treatment effects and clinical trials.  This combination of Julia and Bayesian methods provides a solution to the “two-field problem.”"
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "TTBU37",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": null,
    "name": "Morten Piibeleht",
    "code": "PMKEJN",
    "biography": "Morten Piibeleht is a PhD student at Massey University, New Zealand, doing theory and computational work in the field of atomic physics and QED. In his spare time he is one of the maintainers of Documenter and the JuliaDocs organization."
   }
  ],
  "description": "Documenter can take Markdown files and inline docstrings and combine them into a manual for your Julia package. In addition, it can also run code snippets, verify that the output from code examples is up to date (doctesting) and upload the manual automatically to GitHub from a Travis CI build to be published as a website. Documenter is used by many Julia packages, and for generating Julia's own manual.\r\n\r\nBehind the scenes, Documenter needs to (1) parse and represent Markdown documents, done via the Markdown standard library, (2) run code snippets embedded in the Markdown documents, (3) work with meta-information about functions and types, such as method signatures, and (4) fetch docstrings from your Julia code. Once all that is done, it compiles the result into the chosen output format -- a set of HTML pages or a PDF document.\r\n\r\nThe talk explores how Documenter goes from a make.jl script to a completely rendered and deployed manual. It should give existing users a glance into how Documenter works, but also provide a thorough overview of what is possible with Documenter to prospective new users.",
  "image": "https://pretalx.com/media/juliacon2019/images/TTBU37/logo.png",
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T14:30:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-23T15:00:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "Generating documentation: under the hood of Documenter.jl",
  "abstract": "Documenter compiles docstrings, code snippets, and Markdown pages into HTML or PDF documents and can automatically deploy them as websites, making it easy to create manuals for Julia packages that are immediately available to users. This talk explores what goes into making all of that happen."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "GBWC9F",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": null,
    "name": "Chad Scherrer",
    "code": "A7PDM3",
    "biography": "Chad Scherrer has been actively developing and using probabilistic programming systems since 2010, and served as technical lead for the language evaluation team in DARPA's Probabilistic Programming for Advancing Machine Learning (\"PPAML\") program. Much of his blog is devoted to describing Bayesian concepts using PyMC3, while his Soss.jl project aims to improve execution performance by directly manipulating source code for models expressed in the Julia Programming Language .\r\n\r\nChad is a Senior Data Scientist at Metis Seattle, where he teaches the Data Science Bootcamp."
   }
  ],
  "description": "Probabilistic programming is sometimes referred to as “modeling for hackers”, and has recently been picking up steam with a flurry of releases including Stan, PyMC3, Edward, Pyro, and Tensorflow Probability.\r\n\r\nAs these and similar systems have improved in performance and usability, they have unfortunately also become more complex and difficult to contribute to. This is related to a more general phenomenon of the “two language problem”, in which performance-critical domain like scientific computing involve both a high-level language for users and a high-performance language for developers to implement algorithms. This establishes a kind of wall between the two groups, and has a harmful effect on performance, productivity, and pedagogy.\r\n\r\nIn probabilistic programming, this effect is even stronger, and it’s increasingly common to see three languages: one for writing models, a second for data manipulation, model assessment, etc, and a third for implementation of inference algorithms.\r\n\r\nSolving this “three-language problem” usually means accepting either lower performance or a restricted class of available models and inference algorithms.\r\n\r\nIt doesn’t have to be this way. The Julia language supports Python-level coding with C-level performance. In Julia, Julia’s own code is “first-class”: code can be pulled apart and manipulated as a data structure. This leads to an approach for high-level representation of models, with transformations and optimizations specific to a given model or inference family.\r\n\r\nThis is the approach taken in Soss, a small and extensible Julia library that provides a way to represent and manipulate probabilistic models. In this talk, we’ll discuss the need and for Soss, some of its concepts at a high level, and finally some recent advancements and upcoming opportunities.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T16:45:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-25T17:15:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "Soss.jl: Probabilistic Metaprogramming in Julia",
  "abstract": "This talk will explore the basic ideas in Soss, a new probabilistic programming library for Julia. Soss allows a high-level representation of the kinds of models often written in PyMC3 or Stan, and offers a way to programmatically specify and apply model transformations like approximations or reparameterizations."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "BXYJ8D",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/20200226_165140_DmGtUVY.jpg",
    "name": "Andrew Rosemberg",
    "code": "JATRBX",
    "biography": "Degree in Control Engineering at Pontifical Catholic University of Rio de Janeiro (PUC-RIO), Brazil.\r\nDouble Degree General Engineering at École centrale de Marseille, France.\r\nCurrently enrolled in the Operations Research Masters at PUC-RIO (Electrical Department).\r\nResearcher at Laboratory of Applied Mathematical Programming and Statistics (LAMPS), Brazil."
   }
  ],
  "description": "The hydrothermal dispatch problem is very important for the planning and operation of the electrical system, especially for the Brazilian system. It is composed of an optimization problem in which the generation of generators, energy distribution and hydro storage management are coordinated in order to minimize cost of operation. Often, this problem is formulated with the Multi-stage Stochastic optimization framework, where decisions are taken for various periods and in the presence of uncertainties, since the generation resources are limited and often shared inter-temporally.\r\n\r\nSolving Multi-stage Stochastic optimization is a challenging numerical problem. Therefore, these are commonly solved by a methodology based on the approximation of the bellman equation of stochastic dynamic programming by a piecewise linear function, called Stochastic Dual Dynamic Programming (SDDP). This methodology is preferred because it avoids the high dimensionality of present in classical stochastic dynamic programming.\r\n\r\nThe objective of this work is to build an open source tool for Hydrothermal Multistage Steady-State Power Network Optimization solved by Stochastic Dual Dynamic Programming (SDDP). Problem Specifications and Network Formulations are handled by [PowerModels.jl](https://github.com/lanl-ansi/PowerModels.jl). Solution method is handled by [SDDP.jl](https://github.com/odow/SDDP.jl).\r\n\r\nThe talk will constitute of: (i) An overview of the package; (ii) A brief description of the dependent packages and their integration; (iii) Quick example of the package's usage.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T17:15:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-23T17:25:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "HydroPowerModels.jl: A Julia/JuMP Package for Hydrothermal economic dispatch Optimization",
  "abstract": "[HydroPowerModels.jl](https://github.com/andrewrosemberg/HydroPowerModels.jl) is a Julia/JuMP package for Hydrothermal Multistage Steady-State Power Network Optimization solved by Stochastic Dual Dynamic Programming (SDDP).\r\n\r\nThe objective of this work is to build an open source tool for hydro-thermal dispatch that is flexible enough for the electrical sector to test new ideas in an agile and high-level way, but at the same time using the state-of-the-art implementations of both the SDDP and the dispatch model formulations. For this, we will take advantage of the julia language and the packages, also open-source, which implement the power flow of the electrical dispatch and the Stochastic Dual Dynamic Programming (SDDP), called respectively [PowerModels.jl](https://github.com/lanl-ansi/PowerModels.jl) and [SDDP.jl](https://github.com/odow/SDDP.jl)."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "LGHLC3",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": null,
    "name": "Ludovic Räss",
    "code": "JLLHMF",
    "biography": "Postdoctoral researcher at Standford University"
   }
  ],
  "description": "We showcase the port to Julia of a massively parallel Multi-GPU solver for spontaneous nonlinear multi-physics flow localization in 3-D. The original solver is itself the result of a translation from a Matlab prototype to CUDA C and MPI. Our contribution is an illustration of Julia solving \"the two language problem\": the Matlab prototype and the CUDA C + MPI production code are being replaced by a single Julia code that will serve both further prototyping and production. The solver's parallel and matrix-free design enables a short time to solution and is applicable to solve a wide variety of coupled and nonlinear systems of partial differential equations in 3-D. The employed stencil-based iterative method optimally suits both shared and distributed memory parallelization. As reference, the original Multi-GPU solver achieved a high performance and a nearly ideal parallel efficiency on up to 5120 NVIDIA Tesla P100 GPUs on the hybrid Cray XC-50 \"Piz Daint\" supercomputer at the Swiss National Supercomputing Centre, CSCS. We report the first performance and scaling results obtained with the Julia port. We present additionally our porting approach and discuss the related challenges.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T15:45:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-23T16:15:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "Porting a massively parallel Multi-GPU application to Julia: a 3-D nonlinear multi-physics flow solver",
  "abstract": "We showcase the port to Julia of a massively parallel Multi-GPU solver for spontaneous nonlinear multi-physics flow localization in 3-D. Our contribution is a real-world example of Julia solving \"the two language problem\"."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "Y9B87L",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": null,
    "name": "Lyndon White (@oxinabox)",
    "code": "ECUZBT",
    "biography": "Hopefully by the time of juliacon, offically a PhD gradute, NLP  & ML.\r\nA reseach software engineer at Invenia Labs.\r\nBeen using julia since 0.3.\r\nBroadly speaking: a useful human."
   }
  ],
  "description": "As the saying goes: _\"You can solve that with Cassette\"_.\r\nYou can do anything with Cassette, and debugging is a thing, therefore Cassette can be used for it.\r\nGenerally speaking, you shouldn't solve problems with Cassette that you can solve in any other way.\r\nHowever if you want to build a debugger, the options include building [an entire interpreter](https://github.com/JuliaDebug/JuliaInterpreter.jl),\r\n[going deep into the lowest levels of the compiler/LLVM](https://github.com/JuliaDebug/Gallium.jl/tree/v0.0.4),\r\nor using [Cassette](https://github.com/jrevels/Cassette.jl).\r\nThe other options are certainly good, and indeed the interpreter work has yeilded [Debugger.jl](https://github.com/JuliaDebug/Debugger.jl/).\r\nBut this talk is about doing it with Cassette.\r\n\r\n[MagneticReadHead v0.1.0](https://github.com/oxinabox/MagneticReadHead.jl/tree/v0.1.0) is usable debugger based on easy-to-use Cassette function overdubs.\r\nIt is under 300 lines of code, and allowed setting breakpoints and stepping between function calls.\r\n[MagneticReadHead v0.2+](https://github.com/oxinabox/MagneticReadHead.jl) is featureful debugger based on Cassette IR passes.\r\nIt is under 800 lines of code, and alloweds setting breakpoints at arbitary locations and stepping between IR statements.\r\n\r\nThe talk will first explain the Cassette function overdubs used in v0.1.0 and how you can use them to fairly painlessly instrument julia code at the function call level.\r\nIt will then move on the the much more complex IR passes used in current versions of MagneticReadHead.\r\nExplaining how you can recursively modify julia code at run time to instert the extra functionality needed for debugging.\r\n\r\nAt first Julia IR may seem like a read-only language.\r\nIt is surprisingly easy to read, but actually modifying it... the concept brings on a special kind of head pain.\r\nAfter this talk you will be able to experience that special pain for yourself,\r\nand hopefuly push through it to do something useful.\r\n\r\nThis tuitorial type presentation is for the advanced julia user.\r\nWhile knowledge of Cassette is not required, it is expected that attendees are broadly familar with the idea of what IR is, even if they have no idea how to write it.\r\nEveryone is welcome to come along for the ride.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T16:15:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-25T16:45:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "Building a Debugger with Cassette",
  "abstract": "As the saying goes: _\"You can solve that with Cassette\"_.\r\nThis is a tuitoral on how to use Cassette for building a debugger.\r\nIt explains the core of MagneticReadHead.jl, and how you can build similar tools,\r\nto instrument julia code for your purposes."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "7S9BDD",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/BD_pic.jpg",
    "name": "Daniel Bachrathy",
    "code": "G8GPNR",
    "biography": "Workplace\r\n- 2014- Assistant professor at Budapest University of Technology and Economics, Department of Applied Mechanics\r\n\r\nEducation\r\n- 2006 – 2013\tPhD Programme \r\nBudapest University of Technology and Economics, Department of Applied Mechanics \r\nResearch topic: Cutting dynamics and surface quality \r\n- 2001 – 2006\tMechanical Engineer \r\n\r\nInterests\r\n- Professional:\tStability, Time-Delay, Machining, Dynamics, Vibration\r\n- Hobbies:\tAmerican Football player, 3D computer graphics, Arduino Project, 3D printing, travelling, photography"
   }
  ],
  "description": "Multi-Dimensional Bisection Method (MDBM.jl) is an efficient and robust root-finding package, which can be used to determine whole high-dimensional submanifolds (points, curves, surfaces…) of the roots of implicit non-linear equation systems, especially in cases, where the number of unknowns surpasses the number of equations.\r\n\r\nEngineering application will be presented from the different fields\r\n - determination of the workspace of a robot arm with collision avoidance\r\n - stability (stabilizability) chart computations\r\n - constrained parameter optimisation",
  "image": "https://pretalx.com/media/juliacon2019/images/7S9BDD/s_c.png",
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T11:30:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-25T11:40:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Implicit Geometry with Multi-Dimensional Bisection Method",
  "abstract": "In the proposed talk an efficient root finding algorithm is presented through engineering applications, which are formed as implicit non-linear equation systems."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "3FSTJF",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/bk_small.JPG",
    "name": "Bogumił Kamiński",
    "code": "DHRPEA",
    "biography": "I am a researcher in the fields of operations research and computational social science.\r\nFor development work I mostly use Julia language.\r\n\r\nYou can find more information about me on [my personal website](http://bogumilkaminski.pl/about/) or [GitHub](https://github.com/bkamins)."
   },
   {
    "avatar": "https://pretalx.com/media/avatars/przemyslaw_szufel_www_hkvkuIE.png",
    "name": "Przemysław Szufel",
    "code": "HNA89P",
    "biography": "Przemysław Szufel is an Assistant Professor in Decision Support and Analysis Unit at SGH Warsaw School of Economics, he also a visiting researcher in Ryerson University  (Toronto)  and a member of Computational Methods in Industrial Mathematics Lab in The Fields Institute for Research in Mathematical Sciences in Toronto.\r\n\r\nHis current research focuses on practical application and methods for execution of large-scale simulations for numerical experiments and optimization. He is an author or a co-author of several Open Source tools for high performance and numerical simulation as well as papers on simulation-optimization algorithms. Przemysław is also a co-author of the book \"Julia 1.0 Programming Cookbook: Over 100 numerical and distributed computing recipes for your daily data science workﬂow\", Packt Publishing, 2018."
   }
  ],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T11:40:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-23T11:50:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Analyzing social networks with SimpleHypergraphs.jl",
  "abstract": "A hypergraph is a generalization of a graph where a single edge can connect more than two vertices. Typical applications are related to social data analysis and include situations such as sending a single email to several recipients, a customer giving reviews to several restaurants or analyzing security vulnerabilities of information networks. In many situations the usage of a hypergraph rather than a classical graph allows to better capture and analyze dependencies within the network.\r\n\r\nWe will start by presenting the library and its functionality. As an example a use case with analysis of Yelp reviews will be shown. The presentation will be based on Jupyter notebook and will be very illustrative for researchers planning to do social network modelling in Julia.\r\n\r\nIn the second part of presentation we will show how we made use of typical Julia programming patterns to build the library. This includes overloading Array operators to provide a user an Array-like access to the hypegraphs data, using object composition as a standard inheritance mechanism for generating various representations (views) of a hypergraph and finally, making the hypegraph data structures compatible with LightGraphs.jl by providing new method implementations. This should give the participants an overview of typical patterns used when extending the package ecosystem of the Julia language.\r\n\r\nAcknowledgement: The project is financed by the Polish National Agency for Academic Exchange."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "8ANSVY",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": null,
    "name": "Elliot Saba",
    "code": "B98NWS",
    "biography": "Elliot Saba is a Senior Research Engineer at Julia Computing, where he develops new tools to bolster the Julia community's collective productivity.  From machine learning algorithms to web services, build environments to debugging tools, his greatest weapon against the impossible is patience."
   },
   {
    "avatar": null,
    "name": "Keno Fischer",
    "code": "S8LPFH",
    "biography": null
   }
  ],
  "description": "Machine Learning workloads continue to require greater and greater compute capability, spawning the development of multiple generations of specialized hardware designed to eke out ever greater efficiency in training and inference workloads.  This talk will explore the state of Julia on this hardware platform, showcasing some of the impressive speedups the hardware and provide, alongside some of the restrictions the hardware model imposes upon the dynamic nature of the Julia language.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T16:15:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-23T16:45:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "XLA.jl: Julia on TPUs",
  "abstract": "The intersection of Machine Learning and High Performance Computing: Running Julia code on Google Cloud Tensor Processing Units."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "G7LXYQ",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Dehann Fourie",
    "code": "LCHTZE",
    "biography": "I'm interested in navigation for robotics and state-estimation in general, and have worked a wide variety of robotic platforms before/during/after thesis research (2009-2010 & 2012-2017) from both the University of Johannesburg and MIT / Woods Hole Oceanographic Institute joint Program.  I'm currently continuing research with the MIT Computer Science and Artificial Intelligence Laboratory, and a supporter of more open-source development for progress in both scientific and business development."
   },
   {
    "avatar": null,
    "name": "Sam Claassens",
    "code": "REUAHZ",
    "biography": "I am a software/electronic engineer with 10+ years experience developing software for control systems, robotics, and data analysis. I have a Master's in real-time control systems with specialization in UAV automation. I am contributing to Julia Robotics, focusing on a cloud framework for robot navigation."
   }
  ],
  "description": "We are actively using Julia in algorithmic research and development work for robotic navigation.  In robotic navigation, multiple sensor data are combined such as odometers, cameras, inertial measurement units, lidars, GPS, sonar acoustics, etc.  The dream is to build factor graph based non-Gaussian state-estimation into real-time capable systems.  Julia has enabled the development of newer non-Gaussian inference techniques that would otherwise have been near intractable if attempted with older languages.  Most SLAM systems today are built in C++ with some Python integration while others are using MATLAB with an eye on later C++ implementations.  Switching to Julia has been worth it;  our ongoing efforts are to formalize the benefits of the one-language / fast / distributed / high-level-numerical-syntax of Julia with an open-source development model.  Our approach not only includes on-board computations but also distributed inference with a cloud server model.  JuliaRobotics/Caesar.jl is an umbrella framework alongside dedicated packages such as RoME.jl / IncrementalInference.jl / Arena.jl / ApproxManifoldProducts.jl / GraffSDK.jl.  The JuliaRobotics/Caesar.jl package depends on over 100 other Julia packages, creating challenges with first run compile times and debugging efforts.  Our challenge now is to continue software development, all-round performance improvement, improved user experience, and help grow the JuliaRobotics community.  Although the JuliaRobotics community is still small, we believe that Julia could become a significant language in robotics.  In the mean-time, a multi-language interface is in the works too.  We are actively using Julia in algorithmic research and development work for robotic navigation.  Robotic navigation is generally done by combining data from multiple sensors such as odometers, cameras, inertial measurement units, lidars, GPS, sonar acoustics, etc.  The dream is to build factor graph based non-Gaussian state-estimation into real-time capable systems.  Julia has enabled the development of newer non-Gaussian inference techniques that would otherwise have been near intractable if attempted with older languages.  Most SLAM systems today are built in C++ with some Python integration while others are using MATLAB with an eye on later C++ implementations.  Switching to Julia has been worth it;  our ongoing efforts are to formalize the benefits of the one-language / fast / distributed / high-level-numerical-syntax of Julia with an open-source development model.  Our approach not only includes on-board computations but also distributed inference with a cloud server model.  JuliaRobotics/Caesar.jl is an umbrella framework alongside dedicated packages such as RoME.jl / IncrementalInference.jl / Arena.jl / ApproxManifoldProducts.jl / GraffSDK.jl.  The JuliaRobotics/Caesar.jl package depends on over 100 other Julia packages, creating challenges with first run compile times and debugging efforts.  Our challenge now is to continue software development, all-round performance improvement, improved user experience, and help grow the JuliaRobotics community.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T15:20:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-23T15:30:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Non-Gaussian State-estimation with JuliaRobotics/Caesar.jl",
  "abstract": "Navigation and mapping for robots require data fusion from various sensors, each producing uncertain and opportunistic measurement data.\r\nWe are continuing with a multi-year, native Julia factor graph based simultaneous localization and mapping (SLAM) inference system that grew out of research work on non-Gaussian state-estimation, and is the primary implementation of the \"multimodal-iSAM\" algorithm from robotics literature."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "RAKLRV",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": null,
    "name": "Robin Deits",
    "code": "3B38XC",
    "biography": "Robin recently finished his PhD in robotics from MIT and is excited to have finally completed 23rd grade. He now works at Boston Dynamics, where he trains humanoid robots to do tricks. While at MIT, he helped to start the [JuliaRobotics organization](http://www.juliarobotics.org/), dedicated to developing and promoting Julia tools to advance the field of robotics. \r\n\r\nIn his free time, he enjoys writing and solving puzzles, especially when he can figure out how to use Julia to solve them faster."
   }
  ],
  "description": "Cryptic (or British-style) crosswords are designed to be intentionally vague, misleading, or ambiguous. Each clue \r\ncombines a standard crossword clue with wordplay elements like anagrams, reversals, or homophones, so solving the clue requires understanding both crossword definitions and a combinatorial explosion of possible wordplays. Here are a couple of easy examples: \r\n\r\nClue: \"Spin broken shingle\"\r\nAnswer: \"english\"\r\nExplanation: \"broken\" means to take an anagram of \"shingle\", which produces \"english\", and \"english\" can mean \"spin\" (at least in billiards). \r\n\r\nClue: \"Initially babies are naked\"\r\nAnswer \"bare\"\r\nExplanation: \"initially\" means to take the first letter of \"babies\", giving \"b\". Combining \"b\" and \"are\" gives \"bare\", which means \"naked\". \r\n\r\nWe could try to enumerate every possible thing a word might mean, and every way those meanings might combine, but doing so would result in billions of possibilities, most of which are nonsense. instead, I'll show how we can use tools from computational linguistics to attack this silly problem in a serious way, and I'll show how Julia makes doing so even easier. \r\n\r\nIn particular, I will talk about:\r\n\r\n* Developing a formal grammar for cryptic crossword clues\r\n* Implementing probabilistic parsers which can parse cryptic crossword grammars (or any other grammar, I suppose)\r\n* Squeezing as much performance as possible out of string manipulation in Julia\r\n* Analyzing the meaning of words and phrases with WordNet.jl and machine learning\r\n\r\nTo learn more, check out the code, all of which is available online right now. You can find the parsing code at https://github.com/rdeits/ChartParsers.jl and the solver itself at https://github.com/rdeits/CrypticCrosswords.jl",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T11:00:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-23T11:30:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "The Linguistics of Puzzles: Solving Cryptic Crosswords in Julia",
  "abstract": "If you like using serious scientific tools to do silly things, then this talk is for you. Join me as I explore the intersection of computational linguistics, algorithm design, and machine learning in an effort to seriously overthink cryptic crossword clues."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "ARX8CY",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": null,
    "name": "Dheepak Krishnamurthy",
    "code": "ZWPRXJ",
    "biography": "I am an energy researcher and analyst at the National Renewable Energy Laboratory. My interests are power system operation, optimization, high-performance computing, and programming language theory."
   }
  ],
  "description": "This talk is titled why writing C interfaces in Julia is so easy, but as anyone that has written interfaces to C ABI will know, interfacing with the C ABI is never easy. There can be segfaults, memory leaks, uninitialized memory issues and a host of other challenges to deal with when working through this process. In this talk, I'll briefly describe how the C ABI works, and then describe how `ccall` can be used. I'll also go through many best practices that I've used to ensure a nice clean Julian interface to a shared library. I will show how some best practices regarding writing interfaces to a large number of functions, you can use Julia's type system to guarantee that the users of your Julia library don't accidentally pass the wrong pointer to a function using `unsafe_convert`, and some general advice for programmers interested in writing their own libraries in a lower level language (such as C, C++, Rust, Nim etc) and how to ensure that they can be provided as pre-compiled binaries for Julia packages (using BinaryBuilder and alternatives).",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T11:00:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-24T11:30:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "Why writing C interfaces in Julia is so easy*",
  "abstract": "Julia allows interfacing with shared libraries using `ccall`. This allows calling into compiled binaries that could be written in any language that exposes the C ABI. In this talk, I'll describe best practices to follow for interfacing with C libraries."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "EHG87D",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/13724028_10210296273943692_6813311465492377027_o.jpg",
    "name": "Alex Lew",
    "code": "ANKXZG",
    "biography": "Alex is a first-year PhD student at MIT's [Probabilistic Computing Project](http://probcomp.csail.mit.edu). He's interested in building tools that automate the tedious calculations associated with approximate Bayesian inference, and making probabilistic inference algorithms accessible to software engineers solving practical, everyday problems."
   }
  ],
  "description": "Julia is home to a growing ecosystem of probabilistic programming languages—but how can we put them to use for practical, everyday tasks? In this talk, we'll discuss our ongoing effort to automate common-sense data cleaning by building a declarative dataset description language on top of [Gen](https://github.com/probcomp/Gen). Users of the language can encode domain knowledge about their dataset and the ways in which it might be unclean in short, declarative probabilistic scripts, which are compiled to Gen programs that infer locations of probable errors, impute missing values, and propose likely corrections in tabular data.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T15:45:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-23T16:15:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "Cleaning messy data with Julia and Gen",
  "abstract": "Julia is home to a growing ecosystem of probabilistic programming languages—but how can we put them to use for practical, everyday tasks? In this talk, we'll discuss our ongoing effort to automate common-sense data cleaning by building a declarative modeling language for messy datasets on top of [Gen](https://github.com/probcomp/Gen)."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "K9BBNX",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/RebeccaSarfatiHeadshot.jpg",
    "name": "Rebecca Sarfati",
    "code": "EWVRKJ",
    "biography": "Rebecca is a Senior Research Analyst at the Federal Reserve Bank of New York, employing dynamic stochastic general equilibrium (DSGE) models for macroeconomic forecasting and policy analysis. She holds a dual degree in mathematics and computer science from Brown University."
   }
  ],
  "description": "**Abstract:** Over the past few decades, income and wealth inequality have emerged as defining fixtures of the modern U.S. economy. Born of a desire to study the differential effects of policy decisions on a variegated group of economic actors, heterogeneous agent (HA) models enable researchers to incorporate critical differentiation in household income, wealth, and consumption behavior into their analyses of economic phenomena. Yet, while great academic progress has been made developing such models, many policy institutions have been slow to shift from the “representative agent” paradigm. This is due, in large part, to computational strain surrounding HA models' solution and estimation. However, thanks to speed gains made possible by innovations in computing languages like Julia, what was once too computationally taxing for policy purposes has become both feasible to run and elegant to implement. This talk will provide an overview of the Federal Reserve Bank of New York's (NY Fed) HA dynamic stochastic general equilibrium (DSGE) model development process in Julia, walking through our navigation of Julia-specific functionality in the process. Comparisons of performance relative to MATLAB and FORTRAN will be provided.\r\n\r\n**Description:** Heterogeneous agent models, in contrast to representative agent models, allow for heterogeneity in various features among agents in an economy, at both the household and firm level. Examples of such heterogeneity might include age, risk-tolerance, skills, and discounting of the future --- features that manifest themselves in heterogeneity in the wealth distribution. Recent work in macroeconomic literature reveals the monetary and fiscal policy implications for HA models can differ widely from their representative counterparts. Such models may be implemented in either discrete or continuous time, posing challenges for their intuitive out-of-the-box deployment as well as succinct tailoring of model-specific solution methods. The solving of large-scale macroeconomic models is sufficiently complex in the representative agent case; the dimensionality of problems increases considerably with the addition of heterogeneity, especially in continuous-time, lending itself well to Julia’s strengths.\r\n\r\nIn the past year, our team has ported several HA models—along with algorithms to discretize, linearize, and solve them—from both MATLAB and FORTRAN for integration into our codebase. package. This addition comes at the heals of the release of our [DSGE.jl](https://github.com/FRBNY-DSGE/DSGE.jl) package, whose other components, such as representative agent model solution, estimation, and forecasting, were the subject of past presentations at JuliaCons 2016-2018. I will discuss the respects Julia has provided us technical flexibility in constructing coherent type hierarchies, employing multiple dispatch, and utilizing distributed computing, as well as how we managed various design decisions pertaining to variable scope, typing, and parallelization, so as to optimize for memory usage and runtime. I will cover the technical constraints and considerations imposed by our production environment at the NY Fed, and offer advice for what we found accommodated our cluster setup. Finally, I will shed light on how HA models may expand the toolkit for policymakers and academics.\r\n\r\nDisclaimer: This talk reflects the experience of the author and does not represent an endorsement by the Federal Reserve Bank of New York or the Federal Reserve System of any particular product or service, The views expressed in this talk are those of the authors and do not necessarily reflect the position of the Federal Reserve Bank of New York or the Federal Reserve System. Any errors or omissions are the responsibility of the authors.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T14:30:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-24T15:00:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "Heterogeneous Agent Dynamic Stochastic General Equilibrium (DSGE) Models in Julia at the Federal Reserve Bank of New York",
  "abstract": "This talk will provide an overview of the Federal Reserve Bank of New York's heterogeneous agent dynamic stochastic general equilibrium (DSGE) model development process in Julia, walking through our navigation of Julia-specific functionality in the process. Comparisons of performance relative to MATLAB and FORTRAN will be provided."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "7NRBXW",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Demian Panigo",
    "code": "EGN7YL",
    "biography": "I'm president of APEL (http://apel.la/) and vice-Director of the Center of Workers' Innovation - CONICET/UMET in Argentina (http://citra.org.ar/). I have a PhD in Economics (EHESS-Paris, France) and I'm also teaching advanced macroeconomics and development economics at four different Universities (UNLP, UNDAV, UNQ and UNM). Working on industrial economics over the last three years (more precisely, automotive industry), I'm moving now to innovate on HPC in Econometrics.\r\nhttps://www.researchgate.net/profile/Demian_Panigo"
   },
   {
    "avatar": "https://pretalx.com/media/avatars/Screenshot_20190314-0203392.png",
    "name": "Adán Mauri Ungaro",
    "code": "EU8BNP",
    "biography": "."
   },
   {
    "avatar": null,
    "name": "Nicolás Monzón",
    "code": "YBJFG7",
    "biography": null
   },
   {
    "avatar": null,
    "name": "Valentin Mari",
    "code": "7QTGGW",
    "biography": null
   }
  ],
  "description": "Applied scientific research increasingly uses Fat-Data (e.g. large number of explanatory variables relative to number of observations) for feature selection purposes. Previous version of our all-subset-regression Julia package was unable to deal with such databases. Existing ML packages (e.g. [Lasso.jl](https://github.com/JuliaStats/Lasso.jl)) overcome this problem paying a cost in terms of statistical inference, coefficient robustness and feature selection optimality (because ML algorithms focus on prediction not on explanation or causal-prediction). The new GlobalSearchRegression.jl version combines regularization pre-processsing with all-subset-regression algorithms to efficiently work with Fat Data without losing EC-strengths in terms of sensitivity analysis, residual properties and coefficient robustness.\r\nIn the first 3 minutes, our Lighting talk will discuss GlobalSearchRegression.jl new capabilities. We will focus on the main advantages of merging ML and EC algorithms for feature selection when the number of potential covariates is relatively large: ML provides efficiency and sub-sample uncertainty assessment while EC guarantees in-sample and out-of-sample optimality with covariate uncertainty assessment.\r\nThen, we will show different benchmarks for the new GlobalSearchRegression.jl package against R and Stata counterparts, as well as against their own original version. Our updated ML-EC- algorithm written in Julia is up to 100 times faster than similar R or Stata programs, and allows working with hundreds of potential covariates (while the upper limit for the original GlobalSearchRegression.jl version was 28).\r\nFinally, we will use the last 4 minutes for a live hands-on example to show the Graphical User Interface, execute the ML-EC algorithm with fat data and analyze main results using new output capabilities in Latex-PDF.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T15:00:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-23T15:10:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Merging machine learning and econometric algorithms to improve feature selection with Julia",
  "abstract": "Working on our previous contributions for JuliaCon 2018 (see [GlobalSearchRegresssion.jl](https://github.com/ParallelGSReg/GlobalSearchRegression.jl), [GlobalSearchRegressionGUI.jl](https://github.com/ParallelGSReg/GlobalSearchRegressionGUI.jl), and [our JuliaCon 2018 Lighting Talk] (https://bit.ly/2UC7dr1)) we develop a new GlobalSearchRegression.jl version merging LASSO and QR-OLS algorithms, and including new outcome capabilities. Combining machine learning (ML) and econometric (EC) procedures allows us to deal with a much larger set of potential covariates (e.g. from 30 to hundresds) preserving most of the original advantages of all-subset regression approaches (in-sample and out-of sample optimality, model averaging results and residuals tests for coefficient robustness). Additionally, the new version of GlobalSearchRegression.jl allows users to obtain LATEX and PDF outcomes with best model results, model averaging estimations and key statistics distributions"
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "AADAJW",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/54462922_2209077119331155_8720986057224486912_n.jpg",
    "name": "Rohan McLure",
    "code": "NQ9TLZ",
    "biography": "My name is Rohan, and I am an undergraduate at the Australian National University in Canberra, ACT, studying two degrees in Mathematics and Computer Science. I am part of the undergraduate research stream, where at three occaisions of my degree I undertake individual, semester-long research projects, followed by a final year-long 'Honours' project.\r\n\r\nThe first time I really applied my programming knowledge was in the context of physical simulation. With an interest in Applied Mathematics, the procedure and evolution of computational models for natural phenomena greatly interests me. The requirement for parallelism introduces a challenging but fascinating new field of problems to the research community, and I remain optimistic that Julia will be readily adopted for this task.\r\n\r\nAside from study, I enjoy playing music, soccer, and helping lead a youth group at my church."
   }
  ],
  "description": "We introduce a library to the language, 'ArrayChannels.jl', encapsulating several data parallelism patterns which causes serialisation of arrays between processes to occur in-place. This provides for better handling of processor cache, while retaining the synchronous semantics of Julia's RemoteChannel constructs.\r\n\r\nWe then evaluate the performance of the library by comparison to MPI and standard Julia on a number of microbenchmarks and HPC kernels.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T17:15:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-23T17:25:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Array Data Distribution with ArrayChannels.jl",
  "abstract": "We introduce the ArrayChannels.jl library, which allows communication between distributed nodes to occur between fixed buffers in memory. We explore the effects of in-place serialisation on cache usage and communication performance, and consider its suitability for high performance scientific computing."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "UPLPQW",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Brian Jackson",
    "code": "BJYQ39",
    "biography": "I am a PhD student in the Mechanical Engineering department at Stanford University, advised by Dr. Zachary Manchester. My research focuses on developing algorithms to control robots with complex, nonlinear, and under-actuated dynamics. I am one of the two primary developers of TrajectoryOptimization.jl."
   }
  ],
  "description": "Trajectory optimization is a powerful tool for motion planning, enabling the synthesis of dynamic motion for complex underactuated robotic systems. This general framework can be applied to robots with nonlinear dynamics and constraints where other motion planning paradigms---such as sample-based planning, inverse dynamics, or differential flatness---are impractical or ineffective.\r\n\r\nTrajectoryOptimization.jl has been developed for the purpose of collecting and developing state-of-the-art algorithms for trajectory optimization under a single, unified platform that offers the user state-of-the-art performance, an intuitive interface, and versatility. Initial results using a novel algorithm written in Julia already beat previous methods leveraging NLP solvers such as Ipopt and Snopt.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T15:10:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-23T15:20:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "TrajectoryOptimization.jl: A testbed for optimization-based robotic motion planning",
  "abstract": "Trajectory optimization is a fundamental tool for controlling robots with complex, nonlinear dynamics. TrajectoryOptimization.jl is devoted to providing a unified testbed for developing, comparing, and deploying algorithms for trajectory optimization."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "GEJT9H",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/me_photo_CGEysBj.jpeg",
    "name": "Will Tebbutt",
    "code": "LQKANJ",
    "biography": "Will is a PhD student in the Machine Learning Group at the University of Cambridge, supervised by Rich Turner. He's generally interested in probabilistic modelling and (approximate) inference, and is particularly fond of Gaussian processes (GPs). His work on GPs includes approximate inference for scaling to large problems, their use in both multi-output regression and the ensembling of climate models, and most recently on how best to exploit their unique properties in a probabilistic programming framework."
   }
  ],
  "description": "Gaussian processes (GPs) are probabilistic models for nonlinear functions that are flexible, easy to interpret, and enable the modeller to straightforwardly encode high-level assumptions about the properties of the function in question. In short, they're a really useful component of the probabilistic modelling tool box.\r\n\r\nImplementations to date have not made possible to fully exploit the interpretability of GPs, making it harder than necessary encode prior knowledge and interpret results. Based on the ideas in our recently proposed GP probabilistic programming framework, we have developed Stheno.jl to provide an implementation that is straightforward for the user interested in applying GPs to their problem to use, while remaining hackable for experts and researchers.\r\n\r\nThis talk will provide an intuitive introduction GPs using Stheno.jl. We'll then show how Stheno.jl can be used solve extensions of a classical non-linear regression problem and explore structure in the solution, how it can be used in conjunction with Turing.jl to embed GPs as a component in a larger non-Gaussian probabilistic programme, and to explore how it can be combined with Flux.jl to hardness the complementary strengths of deep learning and probabilistic modelling.",
  "image": "https://pretalx.com/media/juliacon2019/images/GEJT9H/juliacon-img.png",
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T16:15:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-25T16:45:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "Gaussian Process Probabilistic Programming with Stheno.jl",
  "abstract": "Stheno.jl is a probabilistic programming framework specifically designed for constructing probabilistic models based around Gaussian processes. Come to this talk to find out what that means, why you should care, and how you can use it with Flux.jl and Turing.jl to do cool things."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "WNWNYK",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Andrea Neumayr",
    "code": "ATAFQL",
    "biography": "I am a PhD student and I've studied Mathematics. I've been working with Julia for more than two years now. I'm a developer of a modeling and simulation environment of 3D-systems called Modia3D. Our Julia package is https://github.com/ModiaSim/Modia3D.jl.\r\nI'm interested in metaprogramming and numerical analysis in general and I want to learn more about Julia."
   }
  ],
  "description": "The talk is about modeling and simulating mechanical 3D-systems with the Julia package Modia3D.jl. Modia3D initially supports mechanical systems and it shall be expanded into other domains in the future. The package uses the multiple dispatch and metaprogramming concepts of Julia to implement features of modern game engines and multi-body programs such as component-based design, hierarchical structuring, and closed kinematic loops. The mechanical systems are treated as Differential Algebraic Equations which are solved with the variable-step integrator IDA of the Sundials.jl package.\r\n\r\nModia3D performs collision handling with elastic response calculation for convex geometries or shapes approximated by a set of convex geometries. A broad phase is executed where each geometry is approximated by a bounding box and only if the bounding boxes are intersecting, the Euclidean distance or the penetration depth is computed in the narrow phase with an improved Minkowski Portal Refinement algorithm. \r\n\r\nIt is planned to combine 3D modeling closely with equation-based modeling. Therefore, the Julia packages Modia3D and Modia needs to interact, for example a joint of a Modia3D system is driven by a Modia model of an electrical motor and gearbox.",
  "image": "https://pretalx.com/media/juliacon2019/images/WNWNYK/ThreeBar.jpg",
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T15:00:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-23T15:10:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Modia3D: Modeling and Simulation of 3D-Systems in Julia",
  "abstract": "Model and simulate mechanical 3D-systems with hierarchical components, kinematic loops, and collision handling of convex bodies."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "JWEAN3",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/portrait2016_TDY3Lrk.jpeg",
    "name": "Anthony Blaom",
    "code": "CK3MKJ",
    "biography": "Anthony Blaom carries out mathematics research and data science consulting. He resides in Auckland, New Zealand.\r\n\r\nAnthony was initially trained as a mechanical engineer, topping his class at the University of Melbourne in 1991. After completing a MSc in Aeronautics and a PhD in Mathematics at Caltech in 1998, he joined the University of Auckland as a Lecturer. For a while he switched to part-time teaching, focusing on his young children, whom he homeschooled while living on the small island of Waiheke.\r\n\r\nAnthony is a co-creator and the lead contributor to MLJ, a Julia machine learning platform developed at the Alan Turing Institute, London. \r\n\r\n[home page](https://ablaom.github.io)  • [github](https://github.com/ablaom)"
   }
  ],
  "description": "MLJ, an open-source machine learning toolbox written in Julia, has evolved from an early proof of concept, to a functioning well-featured prototype. Features include: \r\n1. A flexible API for complex model composition, such as stacking.\r\n2. Repository of externally implemented model metadata, for facilitating composite model design, and for matching models to problems through a MLR-like task interface.\r\n3. Systematic tuning and benchmarking of models having possibly nested hyperparameters.\r\n4. Unified interface for handling probabilistic predictors and multivariate targets.\r\n5. Agnostic data containers\r\n6. Careful handling of categorical data types.\r\n\r\nIn addition to demonstrating some of these features, we discuss relationships with other Julia projects in the data science domain.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T14:30:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-23T15:00:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "MLJ - Machine Learning in Julia",
  "abstract": "We present MLJ, Machine Learning in Julia, a new toolbox for combining and systematically tuning machine learning models."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "QYG3BZ",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/davidanthoffsmallsquare_Me2FZ2a.jpg",
    "name": "David Anthoff",
    "code": "7JQFVF",
    "biography": "David Anthoff is an environmental economist who studies climate change and environmental policy. He co-develops the integrated assessment model FUND that is used widely in academic research and in policy analysis. His research has appeared in Science, the Journal of Environmental Economics and Management, Environmental and Resource Economics, the Oxford Review of Economic Policy and other academic journals. He contributed a background research paper to the Stern Review and has advised numerous organizations (including US EPA and the Canadian National Round Table on the Environment and the Economy) on the economics of climate change.\r\n\r\nHe is an assistant professor in the Energy and Resources Group at the University of California, Berkeley. Previously he was an assistant professor in the School of Natural Resources and the Environment of the University of Michigan, a postdoc at the University of California, Berkeley and a postdoc at the Economic and Social Research Institute in Ireland. He also was a visiting research fellow at the Smith School of Enterprise and the Environment, University of Oxford.\r\n\r\nHe holds a PhD (Dr. rer. pol.) in economics from the University of Hamburg (Germany) and the International Max Planck Research School on Earth System Modelling, a MSc in Environmental Change and Management from the University of Oxford (UK) and a M.Phil. in philosophy, logic and philosophy of science from Ludwig-Maximilians-Universität München (Munich, Germany)."
   }
  ],
  "description": "This talk will start with a quick end-to-end data science example that exercises all parts of the [Queryverse]( https://www.queryverse.org/) (file IO, data manipulation and plotting). I will then briefly introduce a number of new features that were added over the course of the last year (a native Queryverse table type, various new tabular query operators, some new UI tools and the fastest Julia CSV parsing). The bulk of the talk will center on the internal design of [Queryverse]( https://www.queryverse.org/). Topics will include the monadic design of [Query.jl]( https://github.com/queryverse/Query.jl) (inherited from LINQ) that allows us to easily bridge the tabular world with many other julia data structures, the design principles behind [TableTraits.jl]( https://github.com/queryverse/TableTraits.jl) and how it manages to combine extreme simplicity with great performance, the underlying architecture in [Query.jl]( https://github.com/queryverse/Query.jl) that allows full query analysis, rewrites and optimization, and the engineering principles (in terms of backwards compatibility and testing infrastructure) that drive the [Queryverse]( https://www.queryverse.org/).",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T15:00:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-24T15:30:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "Queryverse - Under the Hood",
  "abstract": "This talk will give a brief overview of the [Queryverse]( https://www.queryverse.org/) functionality and some new features that were added over the last year, and then dive deep into the internal design of [Query.jl]( https://github.com/queryverse/Query.jl), [TableTraits.jl]( https://github.com/queryverse/TableTraits.jl) and many other packages from the [Queryverse]( https://www.queryverse.org/)."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "UUC9UJ",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": null,
    "name": "Takafumi Arakaki",
    "code": "JQB3XK",
    "biography": "I'm a postdoc in theoretical neuroscience.  I'm a member of JuliaPy and JuliaDiffEq organizations and the active maintainer of PyJulia."
   }
  ],
  "description": "",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T15:00:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-25T15:30:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "Transducers: data-oriented abstraction for sequential and parallel algorithms on containers",
  "abstract": "Transducers are composable algorithms that operate on collections of inputs.  This concept is first introduced in Clojure language by Rich Hickey for a fully reusable code for mapping, filtering, concatenation, and similar operations that can be modeled a succession of steps.  By this nature, transducers superficially look like iterators that are used by the majority of programming languages for a similar purpose.  However, the protocol used by transducers is quite different from iterators and results in different characteristics:\r\n\r\n(1) Transducers are driven by a \"generalized\" [`foldl`](https://docs.julialang.org/en/v1.1/base/collections/#Base.foldl-Tuple{Any,Any}) function.  It can implement a specialized looping strategy that is most friendly to the way the data is laid out in memory for a given collection (e.g., two nested loops for vector-of-vectors).\r\n\r\n(2) Some transducers like `Map`, `Filter`, `Cat` and `Scan` can support parallel execution.  Importantly, this is done without re-writing any of the code for those transducers.\r\n\r\n(3) The code composed by transducers is close to the way code is written manually using raw loops.  It seems to result in a good machine code generation.  This also means that enabling SIMD using the `@simd` macro is straight forward.\r\n\r\nIn this talk, I explain the formalism of the transducers and discuss the pros and cons for Julia ecosystem based on my experience in implementing [Transducers.jl](https://github.com/tkf/Transducers.jl)."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "GVYCEL",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/marco.png",
    "name": "Marco Cusumano-Towner",
    "code": "ABTMUE",
    "biography": "Marco is a fourth-year Ph.D. student in electrical engineering and computer science at MIT, working with Vikash Mansinghka in the MIT Probabilistic Computing Project, and Josh Tenenbaum in the MIT Department of Brain and Cognitive Sciences. \r\n\r\nPreviously, Marco completed his Master's degree at Stanford University, where his research focused applied machine learning for computational biology. Marco has spent time in industry developing computational infrastructure and algorithms for genetic testing from high-throughput DNA sequencing data. During his undergraduate studies in at UC Berkeley, Marco worked with Professor Pieter Abbeel on probabilistic and optimization techniques for household robotics.\r\n\r\nMarco is interested in developing programming languages, software systems, user interfaces, algorithms, and theory that make it easier to construct, reason about, and use probabilistic modeling and inference."
   }
  ],
  "description": "Probabilistic modeling and inference are central to many fields. Probabilistic programming systems aim to make probabilistic modeling and inference techniques accessible to a broader audience, and to make it easier for experts in these techniques to develop more complex applications. A key challenge for wider adoption of probabilistic programming languages is designing systems that are both flexible and performant. This talk introduces Gen, a new probabilistic programming system, built on top of Julia, that includes novel language constructs for modeling and for end-user customization and optimization of inference. Gen makes it practical to write probabilistic programs that solve problems from multiple fields. Gen programs can combine generative models written in Julia, neural networks written in TensorFlow, and custom inference algorithms based on an extensible library of Monte Carlo and numerical optimization techniques. The talk will also present techniques that enable Gen’s combination of flexibility and performance: (i) the generative function interface, an abstraction for encapsulating probabilistic and/or differentiable computations; (ii) domain-specific languages with custom compilers that strike different flexibility/performance tradeoffs; (iii) combinators that encode common patterns of conditional independence and repeated computation, enabling speedups from caching; and (iv) a standard inference library that supports custom proposal distributions also written as programs in Gen. This talk shows that Gen outperforms state-of-the-art probabilistic programming systems, sometimes by multiple orders of magnitude, on problems such as nonlinear state-space modeling, structure learning for real-world time series data, robust regression, and 3D body pose estimation from depth images.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T17:15:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-25T17:25:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [
   {
    "description": null,
    "resource": "/media/juliacon2019/submissions/GVYCEL/resources/MIT-CSAIL-TR-2018-020.pdf"
   }
  ],
  "do_not_record": false,
  "title": "Gen: a general-purpose probabilistic programming system with programmable inference built on Julia",
  "abstract": "This talk introduces a new flexible and extensible probabilistic programming system called Gen, that is built on top of Julia. Gen's extensible set of modeling DSLs can express probabilistic models that combine Bayesian networks, black box simulators, deep learning, structure learning, and Bayesian nonparametrics; and Gen's inference library supports custom algorithms that combine Markov chain Monte Carlo, particle filtering, variational inference, and numerical optimization."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "JPNYCR",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": null,
    "name": "Mike Innes",
    "code": "M8VL8C",
    "biography": "I work at Julia Computing on all kinds of Julia things – mainly on turning Julia into a language for differentiable programming, via the Flux machine learning stack."
   }
  ],
  "description": "Last JuliaCon I announced the [Zygote](https://github.com/FluxML/Zygote.jl) tool for analytical differentiation (AD) of Julia code. Flux has now uses Zygote as its default AD,* enabling both a more elegant interface and all kinds of new models that weren't possible before.\r\n\r\nFlux's new APIs are powerful and let us easily express advanced concepts like backpropagation through time. But really, Julia's power is in its awesome open-source ecosystem, with state of the art tools for differential equations, mathematical optimisation, and even colour theory! Come and see how we can take advantage of all of these tools in machine learning models, enabling \"theory-driven\" ML to tackle harder problems than ever.\r\n\r\n* In theory; I write this from 4 months in the past, so who knows.",
  "image": "https://pretalx.com/media/juliacon2019/images/JPNYCR/logo.png",
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T15:45:00-04:00",
   "room": {
    "en": "Room 349"
   },
   "end": "2019-07-24T16:15:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "Differentiate All The Things!",
  "abstract": "Explore Flux's brand-new compiler integration, and how this lets us turn anything in the Julia ecosystem into a machine learning model."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "38EHTQ",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/WhatsApp_Image_2019-03-07_at_23.00.48.jpeg",
    "name": "Vaibhav Dixit",
    "code": "BWE3YN",
    "biography": "Vaibhav is an Undergraduate in Mathematics and Computing at the Indian Institute of Technology (B.H.U.), Varanasi, India. His interests lie in scientific computing and leveraging it to solve modern problems especially in the field of healthcare. He is a contributor to analysis tooling of JuliaDiffEq, specifically the DiffEqParamEstim.jl, DiffEqBayes.jl and DiffEqSensitivity.jl. For the past year he has been involved in the development of PuMaS.jl a Julia based software for simulating and estimating PKPD, PBPK, QSP, etc. models used in pharmacology."
   }
  ],
  "description": "Pharmacokinetic/Pharmacodynamic (PKPD) models are empirical models of the physiological and pharmacological systems often used to describe the kinetics and behavior of drugs in the human body. Nonlinear Mixed Effects (NLME) statistical methods help identify the parameters of the PKPD models and quantify the differences between individuals by integrating models at the population and individual scales. In this talk I introduce PuMaS.jl, a Julia based software for simulating and estimating PKPD, physiology based PK (PBPK), quantitative systems pharmacology (QSP), etc. models used in pharmacology. I will begin by describing approximations to the marginal likelihood which are used to make the quantities efficiently computable and demonstrate on real data how these models can be fit with Optim.jl to reveal population-level characteristics. Additionally, I will demonstrate the ability to utilize DynamicHMC.jl to perform Bayesian estimation of population and individual parameters.  Together, this demonstrates a Julia-based data-driven approach to handle complex problems in individualizing dosing.",
  "image": "https://pretalx.com/media/juliacon2019/images/38EHTQ/WhatsApp_Image_2019-03-07_at_23.00.48.jpeg",
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T16:15:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-25T16:45:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "Simulation and estimation of Nonlinear Mixed Effects Models with PuMaS.jl",
  "abstract": "The talk will introduce the use of PuMaS.jl for simulation and estimation of Nonlinear Mixed Effects Models used in systems pharmacology."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "9D933F",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": null,
    "name": "Tucker McClure",
    "code": "YCND9M",
    "biography": "Tucker has been creating simulations and flight algorithms for aircraft and spacecraft for thirteen years and is currently the guidance, navigation, control, and simulation lead at Zipline International, whose autonomous aircraft deliver blood in emergencies in Rwanda. He loves sharing the subject with others; his online article is now the first result in Google to the query: “How do simulations work?” Throughout his career, he’s built up a vision for a great simulation platform and was thrilled when he found Julia, which is the first language that allows him to bring those ideas together cleanly. He’ll be interested in finding the best espresso in Baltimore."
   }
  ],
  "description": "We’ll see how Julia’s combination of mathy notation, built-in numerical tools, compilation, and metaprogramming opens up new possibilities for creating a simulation environment fit for aircraft, spacecraft, autonomous underwater vehicles, and the like. We’ll examine the special requirements for these types of applications, why elegant solutions have historically been out of reach, and how that picture is beginning to change. Finally, we’ll see how one such simulation environment in Julia has become the backbone of flight algorithm development and testing for a large fleet of autonomous aircraft that deliver life-saving medical supplies in Rwanda and Ghana.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T14:30:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-23T15:00:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "A New Breed of Vehicle Simulation",
  "abstract": "When you design an aircraft or spacecraft, it generally has to work the first time or the consequences are fiery destruction. You simulate a lot. Julia enables not merely a flexible and fast way to write a custom simulation, but in fact an entirely new and powerful breed of simulation architecture."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "BNSCFK",
  "track": null,
  "state": "confirmed",
  "duration": 30,
  "speakers": [
   {
    "avatar": null,
    "name": "Katharine Hyatt, Matthew Fishman",
    "code": "DMTTDJ",
    "biography": "Katharine Hyatt graduated in June 2018 with a PhD in condensed matter physics from UC Santa Barbara. She now works as a postdoctoral researcher at the Flatiron Institute's Center for Computational Quantum Physics, searching for new numerical methods to investigate many-body systems in two (and higher dimensions) and interesting applications for them. She is also a sometime Julia language contributor.\r\n\r\nMatthew Fishman graduated in the spring of 2018 with a PhD in physics from Caltech. His thesis was on the development of new tensor network algorithms for studying quantum many-body systems. In the fall of 2019, he started as an Associate Data Scientist at the Center for Computational Quantum Physics, part of the Flatiron Institute in New York City. There, he is a developer of the ITensor library, a leading software package for performing tensor network calculations."
   }
  ],
  "description": "Tensor network methods are an extremely useful class of simulation algorithms in physics. They work by constructing a graph of tensors -- of which matrices and vectors are low-dimensional examples -- and making local optimizations to these tensors to capture the essential physics of a many-body system. ITensor (Intelligent Tensor) is a leading C++ package created to make tensor network methods accessible to a wider group of scientists and programmers. In this talk, we present ITensors.jl, a ground-up rewrite of ITensor in Julia, which uses the lessons from the C++ project to offer much of the same powerful functionality in a more concise and elegant format, substantially lowering the \"barrier to entry\" for using tensor network techniques. We will present some usage examples that are common in physics applications to exemplify the ITensors.jl user interface and design philosophy. Using Julia, we can create a tensor network package expressive enough to capture a variety of physics that's also accessible enough for more physicists and computer scientists to use.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T11:00:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-23T11:30:00-04:00"
  },
  "submission_type": "Talk",
  "resources": [],
  "do_not_record": false,
  "title": "Intelligent Tensors in Julia",
  "abstract": "We present ITensors.jl, a ground-up rewrite of the C++ ITensor package for tensor network simulations in Julia. We will motivate the use of tensor networks in physics and give some examples for how ITensors.jl can help make the use and development of tensor network algorithms easier for researchers, users, and developers."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "AGNHPU",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Dai ZJ",
    "code": "7T7WDF",
    "biography": "ZJ has more than 10 years of experience in Credit Risk modelling/data science/machine learning in Australia and Singapore."
   }
  ],
  "description": "",
  "image": "https://pretalx.com/media/juliacon2019/images/AGNHPU/sort_perf_10m100_u_LacbdxS.png",
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T11:50:00-04:00",
   "room": {
    "en": "Elm A"
   },
   "end": "2019-07-24T12:00:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Towards Faster Sorting and Group-by operations",
  "abstract": "Julia is increasingly being recognized as one of the big three data science programming languages alongside R and Python. However, Julia’s data ecosystem has had less time to mature when compared to R’s or Python’s. Hence it’s not surprising that some data operations in Julia are slower than their counterparts in R and Python, e.g. group-by.\r\nThis talk discusses how under-utilized fast sorting methods, such as radix sort, can be used to speed up group-by operations in Julia so that Julia’s group-by operations can match (or even surpass) the speed of optimized C-based group-by implementations in R and Python."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "VN7TVD",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Jeffrey Sarnoff",
    "code": "UN78GE",
    "biography": "to be added"
   }
  ],
  "description": "Relax into more reliable floating point.  Get more good digits, keep the ones that count.\r\nRobustly accurate,  `DoubleFloats` offers a way to develop resilient numerics reliably.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T11:30:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-23T11:40:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Counting On Floating Point",
  "abstract": "DoubleFloats.jl offers performant types, Double64 and Double32, with twice the precision of Float64 and Float32. Attendees will gain a working knowledge of how to apply the package in support of more reliably accurate results."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "Q8KE7A",
  "track": null,
  "state": "confirmed",
  "duration": 60,
  "speakers": [
   {
    "avatar": null,
    "name": "Chris Rackauckas",
    "code": "WUWQQ3",
    "biography": "Chris' research and software combines AI with differential equation models of human organs to give patients accurate and personalized drug doses: reducing pain and complications for patients while reducing treatment costs for hospitals.\r\n\r\nChris Rackauckas is an applied mathematics instructor at the Massachusetts Institute of Technology and a senior research analyst at the University of Maryland, School of Pharmacy in the Center for Translational Medicine. Chris's recent work is focused on bringing personalized medicine to standard medical practice through the proliferation of mathematical software. His work on developing the DifferentialEquations.jl solver suite along with over a hundred other Julia packages, not only earned him the inaugural Julia Community Prize and front page features in tech community sites, it is also the foundation of the PuMaS.jl package for Pharmaceutical Modeling and Simulation, set to release in March 2019. Chris’ work with PuMaS makes it possible to predict the optimal medication dosage for individuals, reducing the costs and potential complications associated with treatments. The software is currently being tested in the administration of treatment for neonatal abstinence syndrome (NAS), an opioid withdrawal disorder in newborn babies. NAS requires medically administered morphine doses every four hours to prevent the infants from experiencing withdrawal symptoms. PuMaS is being used to predict personalized safe dosage regimens by incorporating realistic biological models (quantitative systems pharmacology) and deep learning into the traditional nonlinear mixed effects (NLME) modeling framework.  This software and its methodology are also being tested in clinical trials at Johns Hopkins University for its ability to predict an individual's drug response to vancomycin and automatically prescribe optimal doses directly from a patient's health records.\r\n\r\nChris started this work while completing his Masters and Ph.D. at the University of California, Irvine where he was awarded the Mathematical and Computational Biology institutional fellowship, the Graduate Dean's Fellowship, the National Science Foundation's Graduate Research Fellowship, the Ford Predoctural Fellowship, the NIH T32 Predoctural Training Grant, and the Data Science Initiative Summer Fellowship. His research with his advisor, Dr. Qing Nie, focused on the methods for simulating stochastic biological models and detailing how the randomness inherent in biological organisms can be controlled using stochastic analysis. Chris bridged the gap between theory and practice by having a \"wet lab bench\" in Dr. Thomas Schilling’s lab, where these methodologies were tested on zebrafish. Fluorescence Light Microscopy (FLIM) measurements of retinoic acid in the zebrafish hindbrain showed that the predicted control proteins could attenuate inherent biological randomness. The result was a verified mathematical theory for controlling the randomness in biological signaling. Chris received the Kovalevsky Outstanding Ph.D. Thesis Award from the Department of Mathematics upon graduation and was showcased in an interview \"Interdisciplinary Case Study: How Mathematicians and Biologists Found Order in Cellular Noise\" in iScience.\r\n\r\nAs an undergraduate at Oberlin College, Chris was awarded the NSF S-STEM scholarship and the Margaret C. Etter Student Lecturer Award by the American Crystallographic Association, an award usually given for PhD dissertations, for his work on 3+1 dimensional incommensurate crystal structure identification of H-acid. This award was given for Service Crystallography for its potential impact on industrial dye manufacturing."
   }
  ],
  "description": "Many different aspects of dynamical modeling in Julia have seen a recent boom in popularity. A lot of package development focus has been given to the tooling for simulating dynamical models, such as the differential equation solvers of DifferentialEquations.jl and the relevant underlying pieces like IterativeSolvers.jl and NLsolve.jl. In addition, a community of domain-specific modeling tools such as DynamicalSystems.jl, Modia.jl, PuMaS.jl, QuantumOptics.jl, and more than can be listed have all built their own user bases. \r\n\r\nThe purpose of this BoF is to gather the developers of these related tooling to discuss the current state of the ecosystem and develop plans and priorities for next steps. A quick overview of the package space and its recent developments will be given to frame the conversion, with most of the time dedicated to discussion. Possible topics include (but are not limited to) understanding the domains most in need of new and more performant solvers, the utilization of parallelism (multithreading, multiprocessing, and GPu), incorporating symbolic tooling such as ModelingToolkit.jl, and the commonalities of analysis tooling (such as parameter estimation, neural network integration, uncertainty propagation). We invite developers within the community to express their feedback and help guide our next moves within the package space.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-23T11:00:00-04:00",
   "room": {
    "en": "BoF: Room 353"
   },
   "end": "2019-07-23T12:00:00-04:00"
  },
  "submission_type": {
   "en": "Birds of Feather"
  },
  "resources": [],
  "do_not_record": true,
  "title": "Dynamical Modeling in Julia",
  "abstract": "A lot of people are building tooling for differential equation based models in Julia for various domains. DifferentialEquations.jl, DynamicalSystems.jl, PuMaS.jl, Modia.jl, QuantumOptics.jl, etc. and the list goes on. The purpose of this BoF is to gather the developers who are interested in this topic in order to learn about the priorities and gripes within the community in order to plan for the next developments."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "8SBXLD",
  "track": null,
  "state": "confirmed",
  "duration": 210,
  "speakers": [
   {
    "avatar": null,
    "name": "Chris Rackauckas",
    "code": "WUWQQ3",
    "biography": "Chris' research and software combines AI with differential equation models of human organs to give patients accurate and personalized drug doses: reducing pain and complications for patients while reducing treatment costs for hospitals.\r\n\r\nChris Rackauckas is an applied mathematics instructor at the Massachusetts Institute of Technology and a senior research analyst at the University of Maryland, School of Pharmacy in the Center for Translational Medicine. Chris's recent work is focused on bringing personalized medicine to standard medical practice through the proliferation of mathematical software. His work on developing the DifferentialEquations.jl solver suite along with over a hundred other Julia packages, not only earned him the inaugural Julia Community Prize and front page features in tech community sites, it is also the foundation of the PuMaS.jl package for Pharmaceutical Modeling and Simulation, set to release in March 2019. Chris’ work with PuMaS makes it possible to predict the optimal medication dosage for individuals, reducing the costs and potential complications associated with treatments. The software is currently being tested in the administration of treatment for neonatal abstinence syndrome (NAS), an opioid withdrawal disorder in newborn babies. NAS requires medically administered morphine doses every four hours to prevent the infants from experiencing withdrawal symptoms. PuMaS is being used to predict personalized safe dosage regimens by incorporating realistic biological models (quantitative systems pharmacology) and deep learning into the traditional nonlinear mixed effects (NLME) modeling framework.  This software and its methodology are also being tested in clinical trials at Johns Hopkins University for its ability to predict an individual's drug response to vancomycin and automatically prescribe optimal doses directly from a patient's health records.\r\n\r\nChris started this work while completing his Masters and Ph.D. at the University of California, Irvine where he was awarded the Mathematical and Computational Biology institutional fellowship, the Graduate Dean's Fellowship, the National Science Foundation's Graduate Research Fellowship, the Ford Predoctural Fellowship, the NIH T32 Predoctural Training Grant, and the Data Science Initiative Summer Fellowship. His research with his advisor, Dr. Qing Nie, focused on the methods for simulating stochastic biological models and detailing how the randomness inherent in biological organisms can be controlled using stochastic analysis. Chris bridged the gap between theory and practice by having a \"wet lab bench\" in Dr. Thomas Schilling’s lab, where these methodologies were tested on zebrafish. Fluorescence Light Microscopy (FLIM) measurements of retinoic acid in the zebrafish hindbrain showed that the predicted control proteins could attenuate inherent biological randomness. The result was a verified mathematical theory for controlling the randomness in biological signaling. Chris received the Kovalevsky Outstanding Ph.D. Thesis Award from the Department of Mathematics upon graduation and was showcased in an interview \"Interdisciplinary Case Study: How Mathematicians and Biologists Found Order in Cellular Noise\" in iScience.\r\n\r\nAs an undergraduate at Oberlin College, Chris was awarded the NSF S-STEM scholarship and the Margaret C. Etter Student Lecturer Award by the American Crystallographic Association, an award usually given for PhD dissertations, for his work on 3+1 dimensional incommensurate crystal structure identification of H-acid. This award was given for Service Crystallography for its potential impact on industrial dye manufacturing."
   }
  ],
  "description": "The exercises are described as follows:\r\n\r\n- Exercise 1 takes the user through defining the same biological system with stochasticity, utilizing EnsembleProblems to understand 95% bounds on the solution, and perform Bayesian parameter estimation. \r\n- Exercise 2 takes the user through defining hybrid differential equation, that is a differential equation with events, and using adjoints to to perform gradient-based parameter estimation.\r\n- Exercise 3 takes the user through differential-algebraic equation (DAE) modeling, the concept of index, and using both mass-matrix and implicit ODE representations.\r\n- Exercise 4 takes the user through optimizing a PDE solver, utilizing automatic sparsity pattern recognition, automatic conversion of numerical codes to symbolic codes for analytical construction of the Jacobian, preconditioned GMRES, and setting up a solver for IMEX and GPUs.\r\n- Exercise 5 focuses on a parameter sensitivity study, utilizing GPU-based ensemble solvers to quickly train a surrogate model to perform global parameter optimization.\r\n- Exercise 6 takes the user through training a neural stochastic differential equation, using GPU-acceleration and adjoints through Flux.jl's neural network framework to build efficient training codes.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-22T08:30:00-04:00",
   "room": {
    "en": "PH 103N"
   },
   "end": "2019-07-22T12:00:00-04:00"
  },
  "submission_type": {
   "en": "Workshop (half day)"
  },
  "resources": [],
  "do_not_record": true,
  "title": "Solving Differential Equations in Julia",
  "abstract": "This workshop is for both experienced DifferentialEquations.jl users and newcomers. The first hour of the workshop will introduce the user to DifferentialEquations.jl, describing the basic workflow and the special features which are designed to make solving hard equations (automatic sparsity detection, Jacobian coloring, polyalgorithms, etc.) easy. After the introduction, the workshop will break out into groups to work on exercises, where the developers of the library's components will be available for any questions. Some of the exercises are designed for beginners to learn how to solve differential equations and fit models to data, while others are for experienced users to learn the newest performance-enhancement features and upgrade to GPU-accelerated workflows."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "TCVVZN",
  "track": null,
  "state": "confirmed",
  "duration": 50,
  "speakers": [],
  "description": "Posters: \r\n\r\n - \"AMLET meets Julia\" by Bastin, Fabian\r\n - \"JuliaDB: solving the two language problem in analytical databases\" by Shashi Gowda\r\n - \"Mapping the Logic Item Domain with Julia\" by Francis Smart\r\n - \"OrthogonalPolynomials.jl - Optimal evaluation of orthogonal polynomials in ~ 100 lines of Julia\" by Miguel Raz Guzmán Macedo\r\n - \"Oceananigans.jl: fast, friendly, architecture-agnostic, high-performance ocean modeling\" by Ali Ramadhan\r\n - \"Parallel Scenario Decomposition of Stochastic Programming\" by Kibaek Kim\r\n - \"ARCH Models in Julia\" by Simon Broda\r\n - \"Myths, Legends, and Other Amazing Adventures in CSV Parsing\" by Jacob Quinn\r\n - \"Occasionally Binding Constraints in DSGE Models in Julia\" by Vivaldo Mendes\r\n - \"Time Series Analysis and Forecasting with Julia: Nonlinear Autoregressive vs Machine Learning Models\" by Diana A. Mendes\r\n - \"Julia applied in the Factory of the Future\" by Thijs Van Hauwermeiren\r\n - \"NLPeterman.jl: Language processing from the ground up in Julia\" by Mihir Paradkar\r\n - \"Materials.jl for crystal plasticity\" by Ivan Yashchuk\r\n - \"Markov Chain-Monte Carlo Methods for Linear Algebra using Julia v.1.0\" by Oscar A. Esquivel-Flores\r\n - \"Modelling environment for JuliaOpt\" by Manuel Marin\r\n - \"BuyLibre - Cooperative Libre Software Cost-Sharing\" by Clark C. Evans\r\n - \"StateSpaceModels.jl -- A Julia package for time-series analysis in a state-space framework\" by Raphael Saavedra\r\n - \"TileDB: a data management solution tailored for data scientists\" by Jake Bolewski\r\n - \"Growing Machine Learning Solutions on Kubernetes with Julia\" by Patrick Barker\r\n - \"Econometrics.jl for econometric analysis in Julia\" by José Bayoán Santiago Calderón\r\n - \"Bioequivalence Analysis in Julia using Bioequivalence.jl\" by José Bayoán Santiago Calderón\r\n - \"Tackling Stochastic Delay Problems in Julia\" by Henrik Sykora\r\n - \"Julia Web Apps with Mux.jl + Heroku\" by Josh Day\r\n - \"A New Approach of Genre-Based Similarity for User-UserCollaborative Filtering Recommender System\" by Mahamudul Hasan\r\n - \"Real Time Mapping of Epidemic Spread, predict with SIR, Neural Network in Julia\" by Rahul Kulkarni\r\n\r\n### Info for presenters\r\n(This matches the email you've all been sent)\r\n\r\n\r\nWe will have two poster sessions during the morning coffee breaks on Wednesday,\r\nJuly 24 and Thursday, July 25 from 10:10AM to 11AM in room 349.\r\nPlease hang your poster in room 349 by 8:30AM on Wednesday and plan to present during both sessions.\r\nIf you are unable to present on both days, please let us know. \r\n\r\nThe poster boards provided will be landscape (3 feet by 4 feet)",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-24T10:10:00-04:00",
   "room": {
    "en": "Other"
   },
   "end": "2019-07-24T11:00:00-04:00"
  },
  "submission_type": {
   "en": "Break"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Poster Session",
  "abstract": "The poster session will be held in room 349"
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "GYFPM7",
  "track": null,
  "state": "confirmed",
  "duration": 50,
  "speakers": [],
  "description": "Posters: \r\n\r\n - \"AMLET meets Julia\" by Bastin, Fabian\r\n - \"JuliaDB: solving the two language problem in analytical databases\" by Shashi Gowda\r\n - \"Mapping the Logic Item Domain with Julia\" by Francis Smart\r\n - \"OrthogonalPolynomials.jl - Optimal evaluation of orthogonal polynomials in ~ 100 lines of Julia\" by Miguel Raz Guzmán Macedo\r\n - \"Oceananigans.jl: fast, friendly, architecture-agnostic, high-performance ocean modeling\" by Ali Ramadhan\r\n - \"Parallel Scenario Decomposition of Stochastic Programming\" by Kibaek Kim\r\n - \"ARCH Models in Julia\" by Simon Broda\r\n - \"Myths, Legends, and Other Amazing Adventures in CSV Parsing\" by Jacob Quinn\r\n - \"Occasionally Binding Constraints in DSGE Models in Julia\" by Vivaldo Mendes\r\n - \"Time Series Analysis and Forecasting with Julia: Nonlinear Autoregressive vs Machine Learning Models\" by Diana A. Mendes\r\n - \"Julia applied in the Factory of the Future\" by Thijs Van Hauwermeiren\r\n - \"NLPeterman.jl: Language processing from the ground up in Julia\" by Mihir Paradkar\r\n - \"Materials.jl for crystal plasticity\" by Ivan Yashchuk\r\n - \"Markov Chain-Monte Carlo Methods for Linear Algebra using Julia v.1.0\" by Oscar A. Esquivel-Flores\r\n - \"Modelling environment for JuliaOpt\" by Manuel Marin\r\n - \"BuyLibre - Cooperative Libre Software Cost-Sharing\" by Clark C. Evans\r\n - \"StateSpaceModels.jl -- A Julia package for time-series analysis in a state-space framework\" by Raphael Saavedra\r\n - \"TileDB: a data management solution tailored for data scientists\" by Jake Bolewski\r\n - \"Growing Machine Learning Solutions on Kubernetes with Julia\" by Patrick Barker\r\n - \"Econometrics.jl for econometric analysis in Julia\" by José Bayoán Santiago Calderón\r\n - \"Bioequivalence Analysis in Julia using Bioequivalence.jl\" by José Bayoán Santiago Calderón\r\n - \"Tackling Stochastic Delay Problems in Julia\" by Henrik Sykora\r\n - \"Julia Web Apps with Mux.jl + Heroku\" by Josh Day\r\n - \"A New Approach of Genre-Based Similarity for User-UserCollaborative Filtering Recommender System\" by Mahamudul Hasan\r\n - \"Real Time Mapping of Epidemic Spread, predict with SIR, Neural Network in Julia\" by Rahul Kulkarni\r\n\r\n### Info for presenters\r\n(This matches the email you've all been sent)\r\n\r\n\r\nWe will have two poster sessions during the morning coffee breaks on Wednesday,\r\nJuly 24 and Thursday, July 25 from 10:10AM to 11AM in room 349.\r\nPlease hang your poster in room 349 by 8:30AM on Wednesday and plan to present during both sessions.\r\nIf you are unable to present on both days, please let us know. \r\n\r\nThe poster boards provided will be landscape (3 feet by 4 feet)",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T10:10:00-04:00",
   "room": {
    "en": "Other"
   },
   "end": "2019-07-25T11:00:00-04:00"
  },
  "submission_type": {
   "en": "Break"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Poster Session",
  "abstract": "The poster session will be held in room 349"
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "M8G7DD",
  "track": null,
  "state": "confirmed",
  "duration": 10,
  "speakers": [
   {
    "avatar": null,
    "name": "Kristoffer Carlsson",
    "code": "AS3MKE",
    "biography": "I used to be a PhD student at Chalmers University of Technology doing research in material science. Now I work for JuliaComputing, doing all kinds of different Julia stuff."
   }
  ],
  "description": "Julia has for a long time come with a built-in profiler, which is available as the Profile standard library. This profiler is a sampling profiler which means that it collects snapshots of the stacktrace at regular intervals. After execution of the profiled code, the number of traces that were collected in each function can be displayed which gives a good estimate where the code is spending its time. While sampling profiling is a very useful and cheap way of profiling code, there are a few drawbacks:\r\nSince only samples of the execution is collected, exact information of e.g. the time spent in functions or the number of calls to a function is not available.\r\nNot being able to annotate what parts of the code you care about mean that the output from the profiler is sometimes noisy and hard to interpret for non-experts.\r\nAllocations can not be attributed to certain sections of the code.\r\n\r\nTimerOutputs is a Julia package that provides an instrumenting profiler which requires you to annotate your code with labeled sections. While the code is running, TimerOutputs records timing and allocation data in these sections and can then print a summary back to the user. This can sometimes make it easier to get a high level overview of the performance characteristics of the code.\r\n\r\nAn example of the output from TimerOutputs is shown below.\r\n\r\n    ───────────────────────────────────────────────────────────────────────────────\r\n                                            Time                   Allocations\r\n                                    ──────────────────────   ───────────────────────\r\n            Tot / % measured:            6.89s / 97.8%           5.20GiB / 85.0%\r\n\r\n     Section                ncalls     time   %tot     avg     alloc   %tot      avg\r\n     ───────────────────────────────────────────────────────────────────────────────\r\n     assemble                    6    3.27s  48.6%   545ms   3.65GiB  82.7%   624MiB\r\n       inner assemble         240k    1.92s  28.4%  7.98μs   3.14GiB  71.1%  13.7KiB\r\n     linear solve                5    2.73s  40.5%   546ms    108MiB  2.39%  21.6MiB\r\n     create sparse matrix        6    658ms  9.77%   110ms    662MiB  14.6%   110MiB\r\n     export                      1   78.4ms  1.16%  78.4ms   13.1MiB  0.29%  13.1MiB\r\n     ───────────────────────────────────────────────────────────────────────────────\r\n\r\n\r\nThe timing and allocations for each section is presented and the call graph (e.g. that assemble calls inner assemble) is shown by indentation.\r\n\r\nThis lightning talk gives a short summary of the implementation, syntax and use cases of TimerOutputs.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-25T17:15:00-04:00",
   "room": {
    "en": "Elm B"
   },
   "end": "2019-07-25T17:25:00-04:00"
  },
  "submission_type": {
   "en": "Lightning Talk"
  },
  "resources": [],
  "do_not_record": false,
  "title": "TimerOutputs.jl - a cheap and cheerful instrumenting profiler",
  "abstract": "TimerOutputs.jl is a tool that lets you annotate sections in your code so that after execution, a nicely formatted table with information about how much time and allocations were spent in each section can be shown."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "XKURRK",
  "track": null,
  "state": "confirmed",
  "duration": 210,
  "speakers": [
   {
    "avatar": null,
    "name": "Kristoffer Carlsson",
    "code": "AS3MKE",
    "biography": "I used to be a PhD student at Chalmers University of Technology doing research in material science. Now I work for JuliaComputing, doing all kinds of different Julia stuff."
   },
   {
    "avatar": null,
    "name": "Fredrik Ekre",
    "code": "FTWNWJ",
    "biography": "I am a PhD student in computational material mechanics and use Julia both for research, procrastination and as a hobby."
   }
  ],
  "description": "In Julia a lot of important functionality is implemented in packages living outside the core language. There are many reasons for this, for example that user defined types and functions are first class citizens and treated the same way as built-in types and functions, and that Julia's multiple dispatch makes it possible to work together with, and extend, other packages and the core language.\r\n\r\nThere are packages available in Julia for almost everything, for example differential equations, machine learning, data science, debugging and web applications. They are all very different, some are tens of thousands of source lines, while others are single line packages. Basically, the common denominator is that a package is a reusable piece of code wrapped in a specific structure, that solve a specific problem.\r\n\r\nFor newcomers to Julia, or to programming in general, it might seem like a difficult task to author a Julia package. Therefore, in this workshop, we will go through all the necessary steps to create a Julia package. In particular we will learn how to:\r\n\r\n - set up the package structure;\r\n - add package dependencies;\r\n - write unit tests;\r\n - write documentation;\r\n - set up continuous integration (CI);\r\n - release a package.\r\n\r\nThe goal of the workshop is that attendees should be well prepared for getting started with package writing in Julia.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-22T13:30:00-04:00",
   "room": {
    "en": "PH 111N"
   },
   "end": "2019-07-22T17:00:00-04:00"
  },
  "submission_type": {
   "en": "Workshop (half day)"
  },
  "resources": [],
  "do_not_record": true,
  "title": "Writing a package -- a thorough guide",
  "abstract": "In this workshop, we will go through all the necessary steps to create a Julia package. The goal of the workshop is that attendees should be well prepared for getting started with package writing in Julia."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "EHSJY3",
  "track": null,
  "state": "confirmed",
  "duration": 210,
  "speakers": [
   {
    "avatar": null,
    "name": "Chris Rackauckas",
    "code": "WUWQQ3",
    "biography": "Chris' research and software combines AI with differential equation models of human organs to give patients accurate and personalized drug doses: reducing pain and complications for patients while reducing treatment costs for hospitals.\r\n\r\nChris Rackauckas is an applied mathematics instructor at the Massachusetts Institute of Technology and a senior research analyst at the University of Maryland, School of Pharmacy in the Center for Translational Medicine. Chris's recent work is focused on bringing personalized medicine to standard medical practice through the proliferation of mathematical software. His work on developing the DifferentialEquations.jl solver suite along with over a hundred other Julia packages, not only earned him the inaugural Julia Community Prize and front page features in tech community sites, it is also the foundation of the PuMaS.jl package for Pharmaceutical Modeling and Simulation, set to release in March 2019. Chris’ work with PuMaS makes it possible to predict the optimal medication dosage for individuals, reducing the costs and potential complications associated with treatments. The software is currently being tested in the administration of treatment for neonatal abstinence syndrome (NAS), an opioid withdrawal disorder in newborn babies. NAS requires medically administered morphine doses every four hours to prevent the infants from experiencing withdrawal symptoms. PuMaS is being used to predict personalized safe dosage regimens by incorporating realistic biological models (quantitative systems pharmacology) and deep learning into the traditional nonlinear mixed effects (NLME) modeling framework.  This software and its methodology are also being tested in clinical trials at Johns Hopkins University for its ability to predict an individual's drug response to vancomycin and automatically prescribe optimal doses directly from a patient's health records.\r\n\r\nChris started this work while completing his Masters and Ph.D. at the University of California, Irvine where he was awarded the Mathematical and Computational Biology institutional fellowship, the Graduate Dean's Fellowship, the National Science Foundation's Graduate Research Fellowship, the Ford Predoctural Fellowship, the NIH T32 Predoctural Training Grant, and the Data Science Initiative Summer Fellowship. His research with his advisor, Dr. Qing Nie, focused on the methods for simulating stochastic biological models and detailing how the randomness inherent in biological organisms can be controlled using stochastic analysis. Chris bridged the gap between theory and practice by having a \"wet lab bench\" in Dr. Thomas Schilling’s lab, where these methodologies were tested on zebrafish. Fluorescence Light Microscopy (FLIM) measurements of retinoic acid in the zebrafish hindbrain showed that the predicted control proteins could attenuate inherent biological randomness. The result was a verified mathematical theory for controlling the randomness in biological signaling. Chris received the Kovalevsky Outstanding Ph.D. Thesis Award from the Department of Mathematics upon graduation and was showcased in an interview \"Interdisciplinary Case Study: How Mathematicians and Biologists Found Order in Cellular Noise\" in iScience.\r\n\r\nAs an undergraduate at Oberlin College, Chris was awarded the NSF S-STEM scholarship and the Margaret C. Etter Student Lecturer Award by the American Crystallographic Association, an award usually given for PhD dissertations, for his work on 3+1 dimensional incommensurate crystal structure identification of H-acid. This award was given for Service Crystallography for its potential impact on industrial dye manufacturing."
   },
   {
    "avatar": null,
    "name": "Vijay Ivaturi",
    "code": "E9JXDX",
    "biography": null
   }
  ],
  "description": "Phamacometrics is the practice of using mathematical models to predict the effect of drugs on a patient’s internal biology. This field has become a standard part of pharmaceutical research, with major pharmaceutical companies routinely utilizing these methodologies to optimize dosing schedules and analyze clinical trial data for efficacy and toxicity before performing expensive clinical trials. These models are nonlinear mixed effects models where the nonlinearity is given by a system of differential equations. Because the process is limited by the speed and flexibility of the differential equation solvers, there has been increasing interest in using Julia for this practice.\r\n\r\nIn this workshop we will walk both Julia users and pharmaceutical practitioners through the process of pharmacometric modeling in Julia. Pharmaceutical practitioners will be paired with Julia users to work on guided exercises to learn both the pharmacometric modeling workflows and their implementation in Julia. Workshop participants will learn to make use of Pumas.jl and Bioequivalence.jl to perform clinical trial simulations, and analyze the results using the Pumas Non-Compartmental Analysis (NCA) functionality. Users will learn how to implement Pk/Pd models with complex dosing schedules and incorporating population models and estimate population parameters from data. Advanced users can explore the function-based interface of Pumas.jl to define delay and stochastic differential equation models, and optimize the runtime of their simulations using the full functionality of DifferentialEquations.jl. The participants will leave with a clear understanding of how to use the Julia package ecosystem to efficiently handle these difficult pharmacometric models, and will have a new perspective for understanding the differential equation solver advances being discussed at JuliaCon.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-22T13:30:00-04:00",
   "room": {
    "en": "PH 103N"
   },
   "end": "2019-07-22T17:00:00-04:00"
  },
  "submission_type": {
   "en": "Workshop (half day)"
  },
  "resources": [],
  "do_not_record": true,
  "title": "Pharmaceutical Modeling and Simulation with Pumas",
  "abstract": "Pharmacometics is commonly used to optimize drug doses and pre-screen drugs before clinical trials. In this workshop, users familiar with Julia will learn about pharmacometrics and how to perform the model simulations, while pharmacometricians will learn how to use Julia to build the models they know from their field. The focus will be on simulating bioequivalance studies with Bioequivalence.jl, performing nonlinear mixed-effects modeling (NLME) simulation and estimation with Pumas.jl, and non-compartmental analysis (NCA) with the PumasNCA submodule."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "RLDSVL",
  "track": null,
  "state": "confirmed",
  "duration": 210,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/154641-1.jpeg",
    "name": "Matt Bauman",
    "code": "VUPRBT",
    "biography": "Matt Bauman is a Senior Research Scientist at [Julia Computing](https://www.juliacomputing.com), focusing on teaching and training as well as continuing to improve Julia's array infrastructure. He’s been contributing to both the core language and multiple packages since 2014. At his previous position as a Data Science Fellow at the University of Chicago’s Center for Data Science and Public Policy, he longed for dot-broadcasting in Python. He recently defended his PhD in Bioengineering from the University of Pittsburgh, focusing on neural prosthetics."
   },
   {
    "avatar": null,
    "name": "Avik Sengupta",
    "code": "JR9GPS",
    "biography": "Avik Sengupta is VP of Engineering at Julia Computing, Inc. In that role he is responsible for all product development and software engineering at the company.  He's a contributor to the open source Julia programming language, and maintainer of many Julia packages. Previously, Avik has worked on large, complex solutions for world’s leading investment banks, creating single dealer platforms, equity research services and risk and trading systems.  Over the past decade, he has co-founded 2 startups working on AI/ML in the financial services sector.  \r\n\r\nAvik is the author of \"Julia High Performance\", a book about performance optimisation in Julia. He has an MBA from IIM Bangalore, and an MS in Computational Finance from Carnegie Mellon University."
   }
  ],
  "description": "This interactive workshop demonstrates how to write parallel Julia code in a variety of ways, including shared memory computing with threads, multiple processes for distributed computing, and computing on the GPU. Julia makes all these modes of parallelism possible, and the Julia community is continuing to perform active research to make high performance parallel computing easier. Many national labs, major corporations, and universities are already using Julia with parallel computing.\r\n\r\nThe workshop will help you:\r\n* identify the challenges in converting a program from serial to parallel\r\n* discover the many forms of parallelism Julia offers and learn when to use each\r\n* learn how to structure programs to take advantage of parallel computation\r\n* write programs that use an appropriate form of parallelism\r\n\r\nIn this workshop, we will cover\r\n* A quick primer on serial performance\r\n* Multithreading\r\n* Designing parallel algorithms\r\n* Tasks (also known as co-routines or green threads)\r\n* Multi-process parallelism\r\n* A very quick introduction to GPU programming\r\n* Future developments\r\n\r\nParticipants should have basic understanding of non-parallel programming techniques and of Julia itself.",
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": "2019-07-22T13:30:00-04:00",
   "room": {
    "en": "PH 211N"
   },
   "end": "2019-07-22T17:00:00-04:00"
  },
  "submission_type": {
   "en": "Workshop (half day)"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Parallel Computing Workshop",
  "abstract": "Parallel computing is hard.  Julia can make it much easier. In this workshop, we discuss modern trends in high performance computing, how they’ve converged towards multiple types of parallelism, and how to most effectively use these different types in Julia."
 }
]
